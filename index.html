
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Wu's Blogs</title>
  <meta name="author" content="Wu Li">

  
  <meta name="description" content="Python 语言使用回顾 (二) 接着来说Python的使用经验。上次谈到Python语法规范简洁，对于初学者很友善，同时对于老程序员来讲，会发现其比较简单，舍弃了一些不常用的语言特性。但这绝对不意味着Python功能不行，恰恰相反，Python是语言中的狗皮膏药，在各个领域都能发挥其作用。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.wuli.mobi">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Wu's Blogs" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Wu's Blogs</a></h1>
  
    <h2>A blog for saving my articles.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.wuli.mobi" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/15/2016-01-15-pythonexp2/">Python 语言使用回顾 (二)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-15T06:36:33+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:36 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Python 语言使用回顾 (二)</h1>

<p>接着来说Python的使用经验。上次谈到Python语法规范简洁，对于初学者很友善，同时对于老程序员来讲，会发现其比较简单，舍弃了一些不常用的语言特性。但这绝对不意味着Python功能不行，恰恰相反，Python是语言中的狗皮膏药，在各个领域都能发挥其作用。</p>

<p>我们来看看这个狗皮膏药能贴在那些领域。</p>

<p>对于系统编程，我们指的是和文件系统打交道，跟操作系统打交道。对于系统管理员，QA测试，企业IT来言，很多情况下就是要处理文件，处理进程,获取系统提供的一些服务等等。当然也包括调用一些操作系统的命令来间接地完成一些任务。比如使用snmp相关Linux命令来访问snmp agents，结合pexpect和ssh命令来访问远程机器。</p>

<p>可以应用到网络编程，系统自带的TCP／UDP／RAW socket接口，很方便构建自己的网络客户端和服务器端。而且相比于使用C语言借口来写这些程序要便捷的多，这是因为，除过底层的socket接口，它上层针对一般的服务器应用，结合了多线程，多进程来进行处理来自多个客户端的请求，自带并行处理机制。而对于开发者，如果不是特殊，需要特大吞吐量和突发连接的情况下，做一些常用的工具，是非常方便的，你需要关注一些类似特殊的接口方法，根据业务来实现即可。</p>

<p>至于应用层协议的处理，如http，有很多库，最著名的有requests，有句话怎么说来，“谁用谁知道”。 有处理telnet, ftp, smtp, pop3, imap4等各种相关协议的库。</p>

<p>GUI开发工具除过内嵌的tkinter，界面设计出来丑了点，也算事GUI应用。想写好一点的界面可以用PyGTK, PyQT, PyWin32, wxPython等，总有一款适合你。</p>

<p>现时应用中，很多都不直接开发GUI程序，而是以Web GUI来代替，这是因为它的通用性和适用面广。对于GUI后台的开发，PHP有Zend， Ruby有Rails， Python则有Django, Flask等。现成的MVC结构框架，使用和扩展起来都非常方便。</p>

<p>并行计算支持多线程和多进程，虽然多线程因为GIL的存在并不能充分发挥多cpu的优势，但对于那些需要等待的处理，比如终端输入输出，网络读取等，还是有效率上的提高。那么如果使用多进程库的话，则可以发挥多cpu，多核的好处。</p>

<p>如果项目中存在历史遗留下来的使用C或者C++写成的库，想用Python继续使用它们，可以使用SWIG工具非常方便的集成起来，Python就如同调用自己的写的类，变量和函数一样使用C和C++的库。</p>

<p>数据库的处理更加方便，Python定义了无论哪种数据库，在开发其API的时候，都必须遵循Python所定义好的接口，来完成诸如建立连接，获取游标，进行事务处理等借口。这样以来，实现业务逻辑只需要编码一次，换数据库对这些代码基本是透明的。</p>

<p>要说Python还有什么能力，不能不提它在大数据处理，机器学习方面的应用。众所周知，Python自带数据结构不能处理类似向量，矩阵之类的各种处理，但好在有NumPy这个库，能够完成高阶矩阵的运算。 Pandas则是数据处理的利器，最大用处是将数据做成二维表格，能以位置和标签方便的进行索引和各种变形操作。本身提供一个数据框架，让用户在此之上使用自己的模型。 还有SciPy提供各种算法和数学工具包。 为了展现所有的数据处理结果，有Matplotlib库来生提供类似MATLAB接口，绘制各种图表。</p>

<p>我是觉得在各种领域，你都可以发现Python用武之地，自从用了它，很难再回到C++，Java开发的情况。不是有句话说的好么，“人生苦短，要用Python“.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/09/pythonexp/">Python 语言使用回顾</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-09T00:00:00+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Python 语言使用回顾 (一)</h1>

<p>Python是个非常好的语言，用了8年了。从最初对其脚本语言的认知到接触使用到各种高级概念。越发觉得这个语言对于初学者非常友善，同时对于有经验的程序员带来很多帮助，能够在各个方面进行运用，来解决实际的工程问题。</p>

<p>先从友善度来讲，Python对于编程小白或者老程序员都是非常友好的，语法简单易学。现在的受过高等教育的各行各业从业者，基本上都有过使用语言的经验，比如大学我们都学过谭浩强的c语言，至少对于计算机语言都有所认知。对于曾今从理工科毕业尤其是主修通讯，自动控制，信息管理的，可能会接触处更多的诸如汇编语言，都具有编程相关知识和或多或少编程技能。我们来对比C++，Java语言来讲它们语法上的区别，来看Python在语法学习上的友善度。为什么用C++和Java而不是其他语言呢，那是因为它们都是支持OOP的语言，可对比性多一些。那么我们通过一些例子来看。</p>

<p>从最简单的，每个程序都要演示的入门程序的Hello World！来看，C++的语法为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;iostream&gt;
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    std::count &lt;&lt; "Hello, World!\n";
</span><span class='line'>    return 0;   
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Java语法为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class HelloWorld {
</span><span class='line'>    public static void main(String[] args) {
</span><span class='line'>        System.out.println("Hello, World");
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>然后再来看Python的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print("Hello World")</span></code></pre></td></tr></table></div></figure>


<p>C++和Java都需要一个程序入口，Python则一行一行的解释执行；Java需要把所有的东西都写成类，而Python即可面向对象编程，又可以使用传统的过程化方式来编程。</p>

<p>以上是个简单的例子，可能只是觉得似乎需要输入的代码少了。我们再看看其他语法方面。</p>

<p>Python的语法在形式上区别于其他两门语言的最大的特点是Python将缩进与对齐强制变成语法的一部分，比如下面例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for x in range(10):
</span><span class='line'>    if x &gt; 5:
</span><span class='line'>        print(x ** 2)
</span><span class='line'>    else:
</span><span class='line'>        print(x ** 3)
</span><span class='line'>        
</span><span class='line'>    print("Process % done", x)</span></code></pre></td></tr></table></div></figure>


<p>这里的代码缩进，对齐都很整齐，这不是一种简单的装饰或者说为了维护方便。这是强制性的。Python和Java，C++不同，不是使用大括号对&#8221;{&ldquo;和&rdquo;}&ldquo;来表示一个语句块的, 它是通过缩进来表示一个语句块，来区分不同的逻辑层次。 比如后面的 <code>print("Process...")</code>语句如果没有正确缩进，放在和其他<code>print</code>相同的列或者与<code>for</code>处于相同的列，就会出现程序的语义或语法错误。 初次看到Python的这个特性，很多人或许说这不灵活，不能灵活写代码。不过用了一段时间你你就会发现这种设置的好处，最大的好处是增强了程序的可维护性。</p>

<p>使用C或者Java写程序，因为使用大括号来匹配语句块的开始与结束，因此，对于那些不遵守coding guidelines的团队来讲，就没有驱动力奖程序写的简洁，最直接的问题就是不对齐，不工整。源程序的存在目的在于维护，在于程序员之间进行交流。团队中有人写完成程序，随着项目的进展，很可能需要修改增加新的特性。即使产品部署后，也需要修改bug，都需要后续的团队人员来读现有的程序，来理解原先的实现。代码除过让机器去运行，最重要的是用来程序员之间进行交流。</p>

<p>Python语法简洁性的另外一个方面表现在对一些概念进行简化，抛弃不必要的一些语言特性。</p>

<p>比如C++和Java对于类属性和成员函数，都有public，protected和private等存取限定。这种设置对于又经验的程序员可能不觉得困难，但是对于初学者，在诸如外部调用或者继承调用等不同使用场景下可能觉得比较烦杂。这虽然本着安全角度来考虑，但是是通过技术手段来限制，Python OOP就没有这种概念，对于该存取不该存取的属性，并没有技术手段来限制，而是通过一些common rules来形成共识，必须以下横线&#8221;_&ldquo;开通的变量就是private属性，两个下横线&rdquo;__&ldquo;则代表更强private意味。 那么所有的人都遵循这些规则，我们一样可以写出安全程序，那么语法上就没有那么繁杂了。</p>

<p>另外，C++和Java实际上提供了很多不是那么常用的的特性，至少是在频率上不那么常用。那么为什么不大胆的舍弃一些特性使得语言显得简练呢？ 这样最大的好处就是嫌少了团队的学习成本。对于一个人来说，很多时间花费在并不常用的特性学习上可能看不到这个代价，但对于一个团队来讲，这个代价就要倍乘。这是因为，一旦有人在代码中用到这些特性，其他一起维护代码的团队成员就不得不熟悉这些特性，来理解采用这些技术的实现。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/24/resume/">Resume</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-24T00:00:00+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Resume</h1>

<p>I have 17 years&#8217; software engineering experience working for networking industry. I am seeking a long-term position as a software engineer / QA / lead / manager position where I can fully utilize my training, skills and make significant to the success of cooperation.</p>

<p>My personal web site is <a href="http://www.wuli.mobi">here</a>.</p>

<h2>Experience</h2>

<h4>Software Engineer at Cisco Systems  July 2010 – Present</h4>

<p>Focus on automation testing, the framework, tools, etc.</p>

<ul>
<li>Design and develop automatic testing platform which is used for Cisco Video Infrastructure testing</li>
<li>Design and develop automatic testing platform – Achievements including “Cisco Collaboration Awards” and “CTEN (Cisco Test Conference Network) Golden Prize”</li>
<li>Plan and coordinate automation development, define automation development target for each product release, draft execution plan and keep tracking; define strategies for automation development, execution and tracking</li>
<li>As a Scrum master, i coordinate the team in each Sprint and deliver defined user stories</li>
<li>Tool development: Designed and developed automatic deployment tool for end-to-end deployment of Video Infrastructure that is VMware Cloud based. This tool is widely used by internal/external teams.</li>
<li>Cisco internal coacher for Python language.</li>
</ul>


<h4>Software Engineer at Cisco Systems  April 2008 – June 2010</h4>

<p>Tools development and hardware diagnosing.  Various tools including:</p>

<ul>
<li>DRP: Developed Diagnostic Release Portal (DRP), a PHP Zend-framework backend engine based web portal.</li>
<li>OWT project: A online Web Tool for online document editing, auto-versioning system.  PHP Zend plus extjs.</li>
<li>TAKO: A case management system for various business units. The case can be used for board issue tracking. PHP Zend plus extjs.</li>
</ul>


<p>I also took the duty of diagnosing hardware chips and bus that includes:</p>

<ul>
<li>Wrote drivers for chips to verify the functions of SMB and I2C Bus</li>
<li>Wrote C test cases to verity reigisters and ports</li>
</ul>


<h4>Software Engineer at Lucent July 2003 – April 2008</h4>

<p>Responsible for developing automatic testing platform and testing of network products</p>

<ul>
<li>Being a test automation platform (NEAT - Nuremberg Environment Automatic Testing) member for developing framework and process for automatic testing.</li>
<li>Manual testing of various Lucent optical network products.</li>
<li>Wrote tools to manipulate test generators and analyzers such as IXIA, HP37718, etc.</li>
<li>Coached and supported test engineers for script development</li>
</ul>


<h4>Software Engineer at Teraspawn Co, Ltd  November 2003 – May 2008</h4>

<p>Worked on embedded firewall products. These products based on X86 platform with 4 MB FLASH ROM, they also support with manageable web interface and other network tools such as dail-out, dhcp, dns-relay, etc.</p>

<ul>
<li>Developed a simple, robust file system to ensure the I/O security for all configuration data in case of emergency.</li>
<li>Developed a small web server to match the management needs. It supports HTTP1.0.</li>
<li>Migration of other open source software, such as DNS SERVER, DHCP SERVER, etc. into embedded box.</li>
</ul>


<h4>Software Engineer at Netfront information Security Co, Ltd  October 1999 – October 2003</h4>

<ul>
<li>As a software engineer to develop PKI related software development
Supported our customer with all kinds of PKI related APIs.</li>
<li>Enable customer to build their security service based on these encipher/decipher APIs.</li>
<li>Developed functions to manipulating digital certification for B2B, B2C.</li>
</ul>


<h2>Education</h2>

<pre><code>Dalian University of Technology 1994-1998  Bachelor, Physics
</code></pre>

<h2>Skills</h2>

<ul>
<li>[x]Python   / C / LISP / PHP / Tcl/Tk / Shell / JavaScript / Java / Octave</li>
<li>[x]Machine Learning / Data Processing</li>
<li>[x]Network Security / PKI / VMware / OOP</li>
<li>[x]Unix Programming / Kernel Programming</li>
<li>[x]Test Automation / Selenium / Jenkins</li>
<li>[x]TCP/IP / XMPP</li>
<li>[x]Scrum / Continuous Integration</li>
</ul>


<h2>Certifications</h2>

<ul>
<li>[x] Machine Learning:         2014</li>
</ul>


<h2>Hornors and Awards</h2>

<ul>
<li>Cisco Collabration Awards(2011): Fast to build one automation platform for new product testing</li>
<li>CTEN (Cisco Test Conference Network) Golden Prize (2012): Best paper rewards for automatic testing system. The paper contains the introduction for our designed automatic testing systems.</li>
<li>Best Partner Awarded by CDO Learning &amp; Development of China (2014): Cooperated with Cisco Learning &amp; Development department we offered a series Python courses to Cisco employees. As a Python language coacher, my class got a lot of warming feedbacks from employees and won the prize.</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/04/closures/">闭包</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-04T14:27:03+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:27 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>套用维基百科的解释：闭包（closure）是此法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。我们从一个简单地例子来分析这些话在说什么。</p>

<pre><code>def foo(bar):
    def plus_one():
    return bar+1          #1 引用自由变量 bar

    return plus_one
func1 = foo(100)
func2 = foo(101)
print(func1())                #2 bar 仍然存在， 输出为101
print(func2())                #3 bar 仍然存在， 输出为102
</code></pre>

<p>这个例子中，foo 函数中一个局部变量 bar 被一个其内部定义的函数 plus_one 所引用，并且这个函数被当做对象作为返回值返回。当被返回的函数被调用的时候，其运算的时候仍然能够访问得到 foo 所定义的局部变量 bar，即使此时已经不在 foo 函数内部。 这个就是闭包的一个基本用法。</p>

<p>首先确定的是，闭包在创建的时候封闭了当时的一些状态，并且能够此后被调用的时候利用当时的状态信息。上面例子中，诸如局部变量（plus_one的enclosing函数）bar被plus_one所保留，即使离开了 foo 的执行，plus_one 仍够访问这个当初保留的状态，也即 bar 这个变量。</p>

<p>再者，我们看到，根据不同的环境创建的函数保留了不同的状态而在此后表现出不同的行为（输出分别为101和102），比如根据参数不同生成的两个函数 func1和 func2，非常类似模式里面的工厂方法。创建的时候根据不同的输入而此后表现出不同的行为带给程序员很大的灵活性。</p>

<p>最后，在使用闭包的过程中，需要注意，闭包引用的变量可能在后来发生改变，因此也会影响闭包的行为。比如：函数 plus_one 在创建的时候保留了 bar 的状态，但不意味着此后如果 bar 的值再次修改，不会影响 plus_one 的调用结果。修改上面代码如下:</p>

<pre><code>def foo():
    bar = 100                
    def plus_one():
    return bar+1         
bar = 99                 # 在创建plus_one函数对象之后，修改 bar 会影响 plus_one 的调用结果
    return plus_one
func = foo()
print(func())                # 输出100
</code></pre>

<p>可以看到，return 函数对象plus_one之前，修改过 bar 的值，plus_one 的调用使得它会使用最后一次 bar 的赋值。需要注意一下这个特性，尤其是引用的变量处于循环当中。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/30/legb/">LEGB规则与 Python 变量的存取</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-30T16:38:35+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>每种语言都有检索变量的规则，决定了当程序查找一个变量的时候，会去哪里找，遵循什么样的搜索顺序。Python 亦然，Python 内部的查询变量的规则简称 LEGB。它是 Local，Environment，Global，Builtin 首字母的缩写。</p>

<p>具体说来，加入一个函数要操作一个叫做 x 的变量，那么 Python 首先在函数内部，局部（Local）范围来查找这个变量；如果没有找到，则到包含这个函数定义的外围去查找（称作 Enclosing)，这个外围或许是另外一个函数（包括匿名函数），如果还是没有，继续朝外查找，一直到模块级别，从这里定义了全局（Global）变量中寻找；如果仍然没有找到，则查找 Python 内置变量(Built-in)，看是否有相同名字的。</p>

<p>在上述查找过程中，一旦变量找到，就不再继续朝外围查找。也就是说 LEGB 同时也定义了从 L 到 B 得优先级。根据这个规则，读 Python 程序的时候，就非常容易判断程序到底操作的是哪个变量。比如一个文件 spam.py：</p>

<pre><code>eggs = 5
def func():
    eggs = 4
    def set():
       eggs = 3
       print(eggs)

    set()               #1  print 3
    print(eggs)         #2  print 4

func()
print(eggs)             #3  print 5
</code></pre>

<p>屏幕依次会输出3，4，5.  道理遵循 LEGB 规则，  #1 set()函数里对 eggs 进行赋值操作会产生一个 set 函数的局部变量；#2 因为之前的 set() 操作处理的时 set 函数内部的变量，并不影响 func 定义的变量 eggs，所以这个变量内容不变；#3 同理 func() 函数调用并不影响全局定义的 eggs 变量，所以打印的全局变量值仍然是5.</p>

<p>从上面的操作及对变量的影响来看，LEGB 规则确实起到作用，变量的查找遵循由内而外的原则。由内到外的指的是 Local->Enclosing->Global->Built-in</p>

<pre><code>--------------------------------------------------------------
|Built-in(Python):                                           |
|    Python 内置的一些预先定义的名字：包括 open ，Exception 等。   |
|    --------------------------------------------------------|
|    |Global(Module):                                        |
|    |    模块文件最外面定义的变量名，属于模块的变量                | 
|    |    ---------------------------------------------------|
|    |    |Enclosing                                         |
|    |    |    定义在外层包含函数里的名字                        |
|    |    |    ----------------------------------------------|
|    |    |    |Local                                        |
|    |    |    |    函数内部所定义的变量                        |
--------------------------------------------------------------
</code></pre>

<p>那么，如果在函数内部想特意使用外面的变量，而不是产生一个新变量，又如何做呢？ Python 提供两个语句，global 和 nonlocal 来声明外围的变量，而不是在函数内部产生一个同名的局部变量。举例如下：</p>

<pre><code>eggs = 5
def func():
    global eggs
    eggs = 4

hams = 10
    def set():
    nonlocal hams
        hams = 99

    set()               
    print(eggs)         #1  print 4
    print(hams)         #2  print 99


func()
print(eggs)             #3  print 4
</code></pre>

<p>此时屏幕输出4,99,4。 #1输出为4原因显而易见；#2输出99是因为 set()函数调用使用 nonlocal 声明，表示改变的 hams 变量是外围 func()函数内部所定义的变量；#3则是因为 func()调用声明 eggs 是全局变量，进而修改了这个变量的值。</p>

<p>需要注意的是global 与 nonlocal 声明的用法。一个声明了变量属于 module（全局的），一个声明了变量属于外围的（上级函数）。如果在 func（）内部的语句“global eggs”变成“nonlocal eggs”则会引起语法错误，因为 eggs 是个全局变量，使用前需要 global 来声明。</p>

<p>到了这里，我们可以自认为了解了Python如何查询，修改变量。基本上如此，对于一般声明的变量是这个规则。但是对于有些变量，他们的声明作用域比较特殊，需要区别对待，依旧举例说明：</p>

<pre><code>x = 100
lst = [1,2,3]
lst2 = [x for x in lst]
print(x)                   #1 still 100

try:
    1/0
except Exception as x:
    pass

print(x)                   #2 UnboundLocalError: local variable 'x' referenced before assignment
</code></pre>

<p>上面的例子中，注意变量 x，除过普通用法，它还用作在另外两个地方</p>

<ul>
<li><p>Comprehansion 变量:</p>

<p>诸如[x for x in lst]里的x，这里定义的这种变量，它的作用域只是这个表达式，Python 3.x之后放置这些变量与其他变量的冲突，修改其作用域到表达式内部。</p></li>
<li><p>Exception 变量： 诸如 &ldquo;Exception as x&rdquo;, 一旦异常被捕获，x 就用来被存放异常对象，<strong>并且在异常处理 excpt 语句结束后被删除！</strong>, 因此之后的 print(x)会报错！</p></li>
</ul>


<p>当然了，如果你仔细维护你的代码，并且遵循 LEGB 规则，你就不会起名同名变量来做类似操作，因此即使你不知道这两种特殊作用域的变量也没有关系。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/29/issues-of-imports/">Python 包管理以及导入包时候一些问题辨析</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-29T14:16:39+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:16 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>之前写了一点关于Python相对包导入机制的东西。除过概念上要区分传统导入方式，记住包导入时候如何寻找路径之外。还经常会碰见在包管理以及使用上因为随意混合这两种方式所带来的意想不到的后果。</p>

<p>之前说过，对于传统包引用：</p>

<pre><code>import foo
</code></pre>

<p>Python2.x和Python3.x对其的解释是不同的。</p>

<ul>
<li>Python2.x: 寻找当前路径（CWD），然后系统路径</li>
<li>Python3.x: 只查找系统路径</li>
</ul>


<p>那么，加入我们有一个包&#8221;foo&#8221;，其内部模块如下:</p>

<pre><code>foo \
    __init__.py
    main.py
    bar.py
    baz.py
</code></pre>

<p>其中, main是一个主程序，也放在这个包中，内容如下：</p>

<pre><code>import bar
</code></pre>

<p>bar.py内容只有一行，就是加载 baz 包:</p>

<pre><code>import baz
</code></pre>

<p>baz内容略过，不重要。那么我们运行如下命令</p>

<pre><code>python foo/main.py
</code></pre>

<p>无论对于Python2.x和Python3.x，结果都正常，很和谐，没有错误。这是因为无论从相对路径中还是系统绝对路径中， 主程序 main.py 所在的目录都在其中，所以 python3.x 和 python2.x 都能正常工作。但是如果 main.py 不在 foo 目录下面，将其内容修改为<strong>import foo.baz</strong>，如其下所示:</p>

<pre><code>main.py
foo \
    __init__.py
    bar.py
    baz.py
</code></pre>

<p>那么运行python3 main.py会出现异常&#8221;ImportError: No module named &lsquo;baz&rsquo; &ldquo;，这是因为python3.x 只会在系统目录下查找 baz 模块，而系统目录只是一组包含主文件程序文件 main.py 所在目录的列表，里面并不包含baz这个模块。 要解决这个问题，唯有把 foo 所在的目录写入到 sys.path 中去（手工写入或者通过 PYTHONPATH 环境变量）</p>

<p>关于传统的 import mod 语句，重点在于：<strong>在 Python3.x 下，如果工作于包管理模式下，则不会从mod.py 所在目录下查找 mod 模块（除非这个目录被用各种方式加入到 sys.path 中去）</strong></p>

<p>那么对于相对导入 from . import mod 这种语句，我们知道它是用来在包内各个模块至今互相引用的。它的初衷服务于包管理。我们仍然使用包含main.py的最初例子, 这个时候不管 Python2.x还是Python3.x在运行 main.py 主程序的时候都会抛关于无法相对导入模块的异常。Python 不允许你在使用相对导入这种包管理的时候把包的目录当做程序目录。你必须要吧 main.py 从包内部拿出来，比如放在 foo 所在的同级目录下。为什么？ 不清楚。</p>

<p>重点在于，<strong>如果你使用了相对导入，那么就需要将包内部的目录层次完全当做包来使用，不要混合程序文件在其中</strong>。</p>

<p>如果想使用相对导入模式，你会碰到更大麻烦。比如对于包内的模块 bar.py, baz.py， 我怎么在这些文件中加入 unittest，并把这些 module 文件当做程序文件来进行单元测试呢，这可是最好的放 unittest 的地方啊？ 这是一个好问题。</p>

<p>答案是可以用传统的包导入方式来解决。 什么？ 又回去了！！！ 我也不想啊，Python 看到这里我也想找个人抽一抽，费劲理解这么多概念，一会碰到这个问题一会碰到那个问题，最后来还是用老方式好。 这里一点都不 Pythonic。</p>

<p>抱怨归抱怨，如何解决让包内的文件同时可以当做程序文件来执行呢。 举个例子，对于 bar.py，我们使用</p>

<pre><code>from foo import baz
</code></pre>

<p> 一方面可以解决相对导入模式下无法当做程序文件使用；另外一方面可以解决不小心在 sys.path 下找到一个同名的 baz 文件而导入错的事情。当然了，代价就是敲的字符多了，当初从 import baz 到相对导入 from . import baz， 现在时 from foo import baz， baz 如果层次越深敲得越多。</p>

<p>似乎使用绝对导入能够使用的范围更为广泛。那么为什么要存在相对导入这种奇葩呢？他们说，能够解决一个层次复杂的 package 重新组织时候需要修改各个包的麻烦。 我相信这是对的，不过我也相信相对导入带来的麻烦更多。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/22/python-relative-imports/">Python Relative Imports</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-22T10:11:17+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>10:11 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Python Relative Imports</h1>

<p>Python包内模块之间当然可以像我们熟知的包导入方式一样，通过<em>import</em>或者<em>from &hellip; import &hellip;</em>来完成。 但是这里有个细节问题，可能会出现并非开发者所想到的后果。通过举例来说明， 现在要开发一个包（Package）Hello，它的目录结构如下：</p>

<pre><code>Hello\
      __init__.py
      foo.py
      bar.py  
</code></pre>

<p>Hello这个包包含两个文件， foo.py 和 bar.py， 我们说 foo.py 包含一个函数叫做 <em>func</em>，bar.py 希望通过引入 foo 这个包来使用这个函数。那么对于 bar.py 来讲，导入并使用的方式可以如下：</p>

<pre><code>import foo
foo.func()
</code></pre>

<p>这个用法似乎也没啥问题。 但是Python2.x 与 Python3.x 对于<em>import foo</em>的解释是不同的。</p>

<ul>
<li>Python2.x:会在当前包（&#8221;Hello&#8221;）所在的路径中搜索叫做 foo 的包名，然后搜索系统路径(sys.path)</li>
<li>Python3.x:只会搜索系统路径</li>
</ul>


<p>可以看到，对于一些程序，如果既要运行在 Python2.x，又要运行到 Python3.x，可能会出现问题，考虑到 sys.path 里面的目录，其中一个路径恰好也有一个模块是 foo，那么在 bar.py 引入 foo 模块的时候，Python3.x 会用这个模块而非和 bar 在同一个包得模块 foo，当调用<em>foo.func()</em>要么报错（不存在），要么用得不是期望的函数。</p>

<p>那么如何通过显示的手段来指明我们想要引入的包，来避免模块内包互相导入呢出现的上述问题呢？ 这可以使用 Python 的相对导入（Relative Imports）机制。 通过</p>

<ul>
<li><strong>from .foo import func</strong></li>
<li><strong>from . import foo</strong></li>
</ul>


<p>来对包 foo 进行导入。 这种通过一个点来指明包内导入的方式叫做相对导入。</p>

<p>无论是Python2.x或者Python3.x碰见这种语句，都会只在当前包目录中查找想要导入的包，而不会去系统路径中去寻找，因此避免了不当导入。</p>

<p>当然，包得层次结构也不都一定是扁平的，只有一个目录，可能有子目录，子目录下可能还有下级子目录。那么又如何在包内导入其他目录下的模块呢？</p>

<p>有人或许已经猜到，既然像 Unix 访问目录一样，用 “.”表示包内同一个目录。那么可以用“..”表示包层次结构中的上一层。仍旧通过举例说明，有一个复杂的目录结构如下：</p>

<pre><code>Hello \
      __init__.py
      a\
        __init__.py
        b\
          __init__.py
          b1.py
      c\
         __init__.py
         c1.py
</code></pre>

<p>Hello包包含子目录“a”和子目录“c”，其中子目录 “a”又包含二级子目录 “b”。 在目录“b”与“c”内分别有两个模块“b1”与“c1”。模块“c1”想使用“b1”中的函数“func”。</p>

<p>模块“c1”中可以用下面这种方式来引入模块“b1”.</p>

<ul>
<li><em>from ..b.b1 import func</em></li>
<li><em>import ..b.b1</em></li>
</ul>


<p>如同目录行为一样，很好理解，不用赘述。</p>

<p>可是，仍旧有人会说，其实也简单，将 Hello 包所在路径加入 sys.path 中，在模块“c1”中用如下语句也可以：</p>

<pre><code>from Hello.a.b.b1 import func
#
#or
#
import Hello.a.b.b1
</code></pre>

<p>是的，这种方式也可以。但首先，如果目录层次比较复杂，敲的字符会很长，不够经济；再者，如果目录进行挪动，需要改动代码，相对导入能够解决这个问题（相对路径如果保持不变）。</p>

<p>虽然用类似目录结构的方式相对导入包内的模块，但这种语句也只是适合包内导入，位于非包这种组织形式(包含__init__.py)的两个文件，不可以通过这种方式（from . .. import）来互相导入。</p>

<p>总结一下：Python 的相对导入的关键在于</p>

<ul>
<li>它限定了搜索的路径在于包内，而不会盲目的在系统路径中找寻一个相同的名字，避免了误导入。</li>
<li>所有的相对导入通过<em>from &hellip; import &hellip;</em>这种格式来完成</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/07/unicode/">Unicode 以及如何使用 Unicode 编程</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-07T11:07:36+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我们讨论 Unicode和使用编程中使用 Unicode，需要对 Unicode 的一些概念予以澄清，从而知道知道它是什么，它用来解决什么问题。对于很多的程序员来讲，在编程生涯中或多或少听过或者少量用过 Unicode，但是可能对于说清楚它是什么，它如何工作的却没有信心。那么本着回答这些问题的原则，我们来目的性的了解 Unicode 是什么，如何在编程语言中使用（Python）它。</p>

<h1>Unicode的历史起源</h1>

<p>Unicode 的起源源自计算机发展过程中，对于解决多国文字的表示，存储这一问题。</p>

<p>计算机发展初期，并没有这个问题，原因在于，当时的体系结果只处理英文字符即可。这个时候使用的字符集称作 ASCII 码。它将33个控制字符，95个可打印字符的每一个赋予一个7比特的数字。比如，这里面包括了常用的控制键 TAB, \r, \n，数字0-9， 字母A-Za-z等。 这128个字符，用了一个字节的低7位即可表示。对于那个时期的计算机而言足够了，既没有如现在 Mac OSX，Windows 等一样富有表现力的图形界面，也不需要字符界面上做各种花样输出。</p>

<p>当计算机被使用的越来越广泛，越来越多的国家参与到计算机的使用与开发时候，一个新问题马上就浮现出来，那就是对于本国语言的表示示与存储的支持。之前提到的 ASCII 编码集合规定了英文字符用于交互时候的表示，它是通过一个7bit 的数字来表示。那么对于其他的西欧字符，比如字符&#8221;ä&#8221;就无法映射到0-127这个数值范围内。于是有了扩展 ASCII 的 ISO-8859-1(Lantin-1)字符集。Latin-1字符集用到了其他的一些西欧字符，未能能够对其编码，需要把一个字节的8个比特都用到，于是除过 ASCII 定义好的0-127这个数值范围对应的字符外，扩展了128-255的映射，里面包含了诸如ä之类的额外的西欧字符。如下图所示：摘自 <a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1">Wikipedia</a></p>

<p><img src="/images/latin-1.png" alt="LATIN-1" /></p>

<p>到了这里还不够，即使 LATIN-1这种编码仍然没法包含地球上所有国家所使用的字符，也无法包含常用的诸如汉语这样的字符。因此还的定义更多的字符集。</p>

<p>使用中文来举例子，一些常用的简体汉字最初被收纳在 GB2312这个字符集中。GB2312也定义了这些常用汉字的编码，即其对应的数值，这个数值包含着2个字节组成的数字中，被称作区位码。单单从2个字节可以存放的空间来看，能够定义65536个字符，但是实际上对于 GB2312来讲，它只是用到了其中的一部分。按照相关规范的定义，只是用到了其中的一部分，用来编码简体汉字字符。对于包含更多汉的字字符集，有 GBK，GB18030标准。</p>

<p>选用不同的编码标准，即使对于同一个字符，可能也有不同的编码。比如字符&#8221;ä&#8221;在cp857（Turkish） 编码中值是132，但在 Latin-1中是228, 在UTF8中则是0xc3a4。代码页(code page)是字符编码的别名，是特定语言字符集的一张表。这张表描述了可支持的字符的集合及其编码。 由于历史原因，Microsoft，IBM，SAP 等都定义了自己的代码页，同一种编码比如“utf-8&#8221;在 Windows中代码页是1208，微软是65001，SAP 是4110，显得很混乱。不过这都是历史原因了。目前我们要关注的是 Unicode，以及 Unicode 在内存中和以及传输、存储中的表示。</p>

<p>因此围绕各国语言定义了很多字符集，同时定义了这些字符集如何编码（转换成数字的值）。但是仍然不够，如果选取某种字符集及编码方式，一般只能做到同时支持拉丁字符和选取的字符集（比如简体汉字），无法同时支持诸如中文、韩语、阿拉伯文。因此，出现了由非盈利组织<em>统一码联盟</em>负值推广的 Unicode 字符编码方案，旨在赋予每个字符（任何语言）对应一唯一数值的方式来替代现有的字符编码方案。</p>

<p>Unicode 将不同语言中的字符统一编码。其赋予任何语言，任何字符一个唯一的一个值，称作 code point，这个值得范围是 U+0000到 U+10FFFF, 理论上映射1,114,112个字符。因此从空间上来看是够了。</p>

<h1>字符集，Unicode, Coding, Encoding等概念辨析</h1>

<p>前面说了 Unicode 及其以前关于字符编码的一些基本知识。我们基本可以得到一个概念，这么多年来我们实际上面临了一个文字由人传递给机器的一个问题。那就是，如何让计算机表示人类的字符，并且消除发展过程中形成的“局域”化的标准，转向“统一”标准。</p>

<p>注意，Unicode 只是定义了一个更庞大的字符集，并且把其中的每个字符与一个数字对应起来。但是并没有定义如何存储这些数字，比如汉字的“汉”，对应的 code point 值是 u+6c49, 这个值两个字节，Unicode 并没有说它存储成文件是否应该存贮成&#8221;6c49&#8221;这种16进制串或者存贮成一个短整数 6c49，如果考虑到 Little Endian 或者 Big Endian 还要考虑顺序。因此，如果考虑到存储，这里还要进行再次的编码。</p>

<p>让我们对编码（Encoding）这个概念进行一下澄清。之前将到字符集以及如何将字符“编码”成数字，是建立一个概念上的字符与数字之间的意义对应关系。这里并不牵扯到这个数字如何表示，在计算机中用几个字节存储，字节顺序等等。它只一个概念上的字符与数字的对应。这里的编码（Encoding）是抽象层次的编码，准确说来是 “编号”（Coding）；而如果考虑这些数字的最终存储形式等实现细节，则是实现层次的编码,比如 UTF-8, UTF-16, UTF-32.  这里举的例子针对 Unicode。对于简单地ASCII 码，它既是指ASCII 字符的编号，同时也是编码。编码这个概念在 Unicode 相关概念中实在是重要，因此需要理解在提到编码的时候到底指的是哪个层次的编码。</p>

<p>使用图例来区分 编号（Coding） 与 编码（Encoding）之间的区别。他们所在的层次不一样，如下面所示。
<img src="/images/encoding.png" alt="Coding/Encoding" /></p>

<p>一个某种语言的字符，首先对应一个某种规则定义的数值。这是用来定义某种字符集和它的编号规则。然后，在存储的时候，这个编号根据不同的编码规则，生成二进制序列串（比如 Unicode 字符‘汉’按照不同编码规则生成的字节流不一样）。实际上在看关于 Unicode 相关文章的时候，编号和编码这两个词是混用的，但是我们自己心里得清楚这里有两个层次： 一个是数字表示形式，一个是数字存储形式。</p>

<p>因为我们之后要重点关注 Unicode 字符串的处理，而UTF-8编码使用的比较多，我们这里对 UTF-8编码规则做一个介绍：
UTF-8具体的编码方式</p>

<blockquote><ul>
<li>code point 为0-127的（ASCII）编码成一个字节。</li>
<li>128-255的编码成2个字节。</li>
<li>大于0x7ff 的编码成3-4个字节。</li>
</ul>
</blockquote>

<p>当然了，你也可以在存储Unicode 字符串的时候选择 UTF-16方式。那么别人拿到这个文件，他如何得知以什么方式打开这个文件，或者说如何解码呢？
这里有个 BOM（Byte Order Mark）这个概念，在文件的头部，有一些特殊字符，来表明这个文件存储的时候以什么方式编码的。比如文件头碰到“EF BB BF”我们可以得知这个文件是 UTF-8编码，碰见“FE FF”可以得知这个事以 UTF-16进行编码的。完整的列表可以参考<a href="http://en.wikipedia.org/wiki/Byte_order_mark%20Wikipedia">Wikipedia</a></p>

<h1>操作系统的支持</h1>

<p>常用的操作系统 Windows，Linux，Mac OSX都已经支持 Unicode</p>

<h1>编程语言的支持</h1>

<p>Unicode 字符集赋予任意一个字符一个唯一的值。那么我们平常书写的程序中，使用字符串的时候，这些字符串在内存中如何表示呢？对于早期用 ASCII 码字符串，这个问题很好理解。比如对于 C 语言处理 ASCII 字符串，我们一般是在内存中生成一个字节数组，用来存储字符串对应的 ASCII 值，最后用0来结尾。到了 Unicode 时代，我们知道一个字节肯定不行了，那么对于Unicode 字符串，有的语言比如 Python 是在内存中存放这些字符对应的 code points，对于字符串的一些操作如索引，分割，拼接也就是对这些 code points 做相应的动作。最后这些字符串如果想要传输或者存储，则先用诸如 UTF-8, UTF-16等编码然后再处理。</p>

<h1>使用 Python 和 Unicode</h1>

<p>在 Python，尤其是 Python 3.X 中处理 Unicode 字符串异常的方便。我们通过一些例子来了解关于 Unicode 字符串的一些处理。</p>

<h2>普通字符串操作</h2>

<p>声明Unicode字符串，在 Python3中，所有的字符串都是 Unicode 字符串，所以你只要如下面声明一个字符串，那就已经是一个 Unicode 字符串了</p>

<pre><code>s = '汉字'
</code></pre>

<p>那么它的长度呢</p>

<pre><code>len(s)                                 =&gt; 2
</code></pre>

<p>完美，并不会出现奇怪的长度居然是4，6啊之类的怪异数字，2个字符就是2个字符，不管它们是什么语言的字符</p>

<p>那么对于一些字符，或许我们键盘没有输入法，但是我知道它的 code point，如何输入呢？</p>

<pre><code>s = '\u6c49\u5b57'                  =&gt; '汉字'
</code></pre>

<p>使用<em>\uNNNN</em>或者<em>\UNNNNNNNN</em>这种方式可以从 code points 来生成 Unicode 字符串。</p>

<p>显式的对 Unicode 字符串进行编码会生成字节数组，参数 encoding 可以选择任何支持的编码方式，大约有100多种，可以参考Python 库手册所定义的编码方式<a href="https://docs.python.org/3/library/codecs.html#standard-encodings%20Standard%20Encodings">Standard Encodings</a>. encode、decode 方法的缺省编码都是 utf8。</p>

<pre><code>s.encode(encoding='utf8')             =&gt; b'\xe6\xb1\x89\xe5\xad\x97'
</code></pre>

<p>从字节数组解码生成字符串对象</p>

<pre><code>b = s.encode(encoding='utf8')
s = b.decode(encoding='utf8')             =&gt;'汉字'
</code></pre>

<p>另外一种字符串对象与字节数组转换的方式</p>

<pre><code>b = bytearray(s, 'utf8')      =&gt;b'\xe6\xb1\x89\xe5\xad\x97'
s = str(b, 'utf8')                 =&gt;'汉字'
</code></pre>

<p>注意在这个例子中，encoding 不再是字典参数，encoding 参数也没有缺省值，如果不提供的话，可能出现不适期望的结果， 比如</p>

<pre><code>b = b'abc'
s = str(b)                =&gt;"b'abc'"
</code></pre>

<p>字符串并未还原成&#8217;abc&#8217;，而是生成字符串&#8221;b&#8217;abc&#8217;&#8221;</p>

<h2>源文件字符集编码声明</h2>

<p>在写 Python 程序的时候，源文件本身可能含有多国语言，甚至源文件中一些变量名，函数名本身也支持多国语言（Python 支持），比如声明一个变量如下：</p>

<pre><code>变量 = 100
</code></pre>

<p>以中文名定义了一个变量。  这些由非全 ASCII 码构成的源文件本身在存储到硬盘的时候，也需要进行编码。 因此 Python 解释器需要知道在加载这些源文件进行执行的时候，首先要能够读取构成程序的代码字符串。Python 在文件头的注释里面，可以添加如下定义：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: &lt;encoding name&gt; -*-
</code></pre>

<p>或者</p>

<pre><code>#!/usr/bin/env python
# coding: &lt;encoding name&gt;
</code></pre>

<p>来指明。</p>

<h2>文件操作</h2>

<p>文件处理操作的模式有两种，文本模式与二进制模式。对于将 utf8格式的文件来说，可以将其看做是文本文件，也可以将其看做是二进制文件。只是在读取其内容还原成字符串对象的时候步骤不同。</p>

<p>首先考虑文本方式，Python3.x 提供的 open 函数增加了一个 encoding 参数，用户当以文本方式打开文件的时候，将会以此参数指定的编码方式来进行编解码。这个过程对于调用者来讲是透明的，自动的。通过 read(), readlines()之类的结果，读取的结果是字符串对象。通过 write(), writelines()接口写入的时候，Python 会自动进行字符串的编码，想字节数组写入文件中。</p>

<pre><code>s = "这是 unicode 字符串"
with open("unicode.txt", 'w', encoding='utf8') as outf:            
    outf.write(s)
with open("unicode.txt", 'r') as inf:                    #缺省以 utf8方式打开
    s = inf.readline()
print(s)                                                 =&gt; "这是 unicode 字符串"
</code></pre>

<p>如果以二进制方式打开的话，那么写入和读取文件都是字节数组。这些字节数组在写入的时候需要调用者调用 encode 方法显式地生成，或者读取的时候使用 decode 方法显式地解码。</p>

<pre><code>s = "这是 unicode 字符串"
with open("unicode.txt", 'wb') as outf:
    outf.write(s.encoding())                        #手工编码
with open("unicode.txt", 'rb') as inf:
    b = inf.read()
s = b.decode(encoding='utf8')                       #手工解码
print(s)                                             =&gt; "这是 unicode 字符串"
</code></pre>

<p>到此，基本上应该明白了啥是 Unicode，基本原理是什么以及如何在 Python 中使用。其他的一些语言如 Java, C++没有经验，不知道是否如此方便的处理 Unicode，但是网上搜到的关于 C++关于处理 Unicode 的一些例子，在解决 Unicode 字符串的 Indexing、slicing 以及可移植性上似乎很是麻烦，我不禁陷入了深深的沉思，这种面向内存编程的语言，真是让程序员过多的考虑构建合适的辅助工具而不能专注于要解决的业务问题。面对日新月异的互联网时代，这些语言何去何从呢？</p>

<p><b><img src="http://img.blog.csdn.net/20141031165003296" alt="装B 状-pic from CSDN" /> </b>
<b><a href="http://img.blog.csdn.net/20141031165003296">装B 状-pic 引用自 CSDN</a></b></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/03/learning-pandas-1/">Learning Pandas (1) - DataFrame Indexing and Slicing</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-03T08:29:46+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2014</span></span> <span class='time'>8:29 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>总是记不着DataFrame中各种Indexing和Slicing操作，也是因为用得少的缘故。很多操作非常像numpy.ndarray的操作，很多又像字典操作，又有类似 sequence 的操作。总之似乎很方便，前提是都得知道该怎么用。</p>

<p>因此整理一下，权当笔记。</p>

<p>首先构造一个试验用的 DataFrame。</p>

<p><img src="/images/pandas-df.png" alt="frame" /></p>

<p>这个 DateFrame 的索引（index）是基于时间的，他得列分别给予标签&#8217;one&#8217;, &lsquo;two&rsquo;, &lsquo;three&#8217;。那么关于索引，有以下几种目的：</p>

<h1>Indexing</h1>

<h2>获得某一行</h2>

<p>分为两种情况.
第一，如果你知道index的值，比如&#8217;2012-01-01&#8217;，你可以使用</p>

<pre><code>&gt;&gt;&gt;frame.ix['2012-1-1'] 
&gt;&gt;&gt;frame.ix['2012-01-1']
&gt;&gt;&gt;frame.ix['2012-01-01']
</code></pre>

<p>来做索引，可以看到，这个给的 key，只要能够正确转换成时间即可。这样，就可以把第一行取出来，生成一个 Series 对象返回；</p>

<p>第二种情况，你可能并不清楚这个 Key，但是你知道你想要第几行数据，比如说第一行，那么你可以用</p>

<pre><code>&gt;&gt;&gt;frame.ix[0]
</code></pre>

<p> ix 会猜你到底给的是个 标签 类型的还是一个数字类型的索引。当然了，特别要注意，当你的标签，也就是索引本身恰好是数字类型的话，第二种方式可能<strong>会造成歧义</strong>，而返回非期望的结果。</p>

<p>DataFrame 其实还提供了另外的索引方法，</p>

<pre><code>&gt;&gt;&gt;frame.iloc[idx] 
</code></pre>

<p>来明确指定需求一个数字做索引，返回需要的行;</p>

<pre><code>&gt;&gt;&gt;frame.loc[label_idx] 
</code></pre>

<p>则需要一个标签做索引。网上看到有人做过实验，iloc,loc的效率不及ix，没有亲身试过。</p>

<h2>获得某一列</h2>

<p>也分类似两种情况，知道列的标签与否。如果知道，比如可以使用</p>

<pre><code>&gt;&gt;&gt;frame.ix[:,'one']
</code></pre>

<p>取出第一列。如果不知道，使用</p>

<pre><code>&gt;&gt;&gt;frame.ix[:,0]
</code></pre>

<p>取出第一列。当然了，也要注意标签恰好是数字类型而出现歧义。</p>

<p>如果基于标签的索引，还有两种种快捷方式，将列的标签作为 key，将 DataFrame 当做字典来存取，如</p>

<pre><code>&gt;&gt;&gt;frame['one']
</code></pre>

<p>取出第一行。或者将某行当做DataFrame的成员变量哪有存取，如</p>

<pre><code>&gt;&gt;&gt;frame.one
</code></pre>

<p>都可以将第一列当做Series 对象返回</p>

<h2>获得指定行指定列</h2>

<p>仍然是两种情况，基于数字或基于标签的索引，比如去第三行第二列数字8，有如下索引方式：</p>

<pre><code>&gt;&gt;&gt;frame.ix[2,1]
&gt;&gt;&gt;frame.ix['2014-1-1', 'two']
&gt;&gt;&gt;frame.ix[2, 'two']
&gt;&gt;&gt;frame.ix['2014-1-1', 1]
</code></pre>

<p>是不是很灵活啊？ 太灵活了！受不了了！这还没完，还有方法呢，要取出8，还有</p>

<pre><code>&gt;&gt;&gt;frame['two'][2], 
&gt;&gt;&gt;frame.two[2]
</code></pre>

<p>还有 at（基于标签的）和 iat（基于数字的），如</p>

<pre><code>&gt;&gt;&gt;frame.at[datetime.datetime(2014,1,1), 'two']
&gt;&gt;&gt;frame.iat(2,1)
</code></pre>

<p>还有类方法</p>

<pre><code>&gt;&gt;&gt;frame.get_value(pd.Timestamp('2014-1-1', 'two')
</code></pre>

<p>是不是头很大，不管你是不是头大，我是有点晕。太多的选择真不符合 Python style。</p>

<h1>Slicing</h1>

<p>有了Indexing的各种手段，来学习 Slicing 的时候有许多类似的概念能够用得到。仍旧针对行与列来操作。</p>

<h2>取多行</h2>

<p>比如取第一、二行，返回仍旧是一个 DataFrame。</p>

<pre><code>&gt;&gt;&gt;frame.ix[0:2]
&gt;&gt;&gt;frame.ix[[0,1]]
&gt;&gt;&gt;frame.ix['2012-1-1':'2013-1-1']       
&gt;&gt;&gt;frame.ix[pd.DatetimeIndex(['2012-1-1','2013-1-1'])]
</code></pre>

<p>前2个方法比较好理解，与NumPy里面的数组操作方式一样，基于数字做索引。 第三种方式给定一个范围，这两个标签之内的所有行都取出（包括最后一个标签对应的行，与数字索引不同）；第四种方式则显得间接，必须显式的将字符串转换成时间索引，来获取其对应的行（FIXME， frame.ix[[&lsquo;2012-1-1&rsquo;,&lsquo;2013-1-1&rsquo;]]不工作）</p>

<h2>取多列</h2>

<p>取出第一、二列</p>

<pre><code>&gt;&gt;&gt;frame.ix[:,0:2]
&gt;&gt;&gt;frame.ix[:,[0,1]]
&gt;&gt;&gt;frame.ix[:,'one':'two']
&gt;&gt;&gt;frame.ix[:,['one','two']
&gt;&gt;&gt;frame[0:2]
&gt;&gt;&gt;frame[[0,1]]
&gt;&gt;&gt;frame[['one','two']]
</code></pre>

<p>第一二种方式基于数字做索引；第三种基于标签，两个标签之间的所有列都取出（包括截止标签对应的列）；第四种提供一个标签列表，属于这个列表中的列都取出;第五、六种是1，2的快捷方式，第七种是第四种方式的快捷操作，没有第三种的快捷方式。</p>

<p>因此，似乎是用标签来做 slicing 的时候，是用类似列表的 <em>start:end</em> 不是很管用。</p>

<p>总体看来，ix 的各种操作很方便获得行，而是用 frame[]类似的快捷方式能方便得获得各种列。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/19/svm/">支持向量机 (SVM)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-19T08:42:38+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>8:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>支持向量机 (Support Vector Machine)</h1>

<p>支持向量机从字面意思上完全得不到要领。支持&hellip;向量机&hellip;？干嘛要支持机器？了解到底这是一个什么东西之前，我们先看看它另外一个别名，“最大边界分类器”（Maximum Margin Classifier）。这个就有点意思了，首先是个分类器，再者是基于边界进行分类，再加上个限定词“最大”。这是一个基于直觉上的形象说法，在探讨算法本身之前，我们先看看，在一个二维空间内，对于线性可以区分的两类数据如何划分它们的边界，以此来获得关于所谓的最大边界分类的一个初步认识。</p>

<p>以下图来自Wikipedia
<img src="http://upload.wikimedia.org/wikipedia/commons/2/20/Svm_separating_hyperplanes.png" alt="SVM" /></p>

<p>这里明显有两组不同样本，在机器学习中我们可以通过神经网络或者逻辑回归或者其他算法来做分类处理，但是从直觉上，我们可以看到，实际上可以在它们中间划分一条线来进行分割。这是一个很自然地想法，问题是，如何来划这个分割线。不同的人有不同的画法，在这里总共有3条直线来划分，H1，H2 和 H3。其中 H3 这个划分是错误的，它没有将多数样本正确区分。H1这条线可以说区分了样本，但是没有 H2 这条线的划分好。这是因为，H1的划分并不在两个样本集合边缘的正中间，如果新来一个样本来计算分类的话，很容易错误分类。而 H2 这条线则使得两组样本的边缘最大化，是一个优选的答案。</p>

<p>现在对于分类器而言，我们的问题就是根据这个想法，如何找到这个最优的分割线。这个例子本身是用得二维空间，通过线段来分割两组样本。对于多维空间，我们是要寻找一个超平面（Hyperplane），来分割样本。</p>

<p>首先我们定义包含 m 个样本，n 个 features的集合为：</p>

<p>$$\mathcal{D}=\{(x_i,y_i)|x_{i}\in{R^{n}},y_i\in\{-1,1\} \}_{i=1}^{m}$$</p>

<h2>拉格朗日对偶（Lagrange duality）- 数学理论基础</h2>

<p>我们之前已经知道我们所要找寻的目标是最大化2/w，这个问题可以换种表述方式而不影响结果。那就是，我们找寻的目标是最小化 $w<sup>2</sup>/2 $。</p>

<p>在目前的情况下，似乎很难找到这样的 w，但是这里有一些约束，可以帮助我们进行寻找。这些约束显而易见，对于我们所有的样本，它们对应的值不是>=1，就是&lt;=-1。</p>

<p>在继续推导之前，先介绍一下拉格朗日对偶。说要寻找一个函数 f(x) 的最小值，这个函数符合一些约束。</p>

<p>$$ \underset{w}{min}\quad f(w) $$
$$  s.t. \quad h_i(w)=0, \quad i=1,2,&hellip;,l.$$</p>

<p>对此，我们定义拉格朗日方程</p>

<p>$$\mathcal{L}(\mathcal{w},\beta)=f(w)+\sum_{i=1}^{l}\beta_ih_i(w)$$</p>

<p>$\beta_i$被称作拉格朗日乘子(Lagrange multipliers)，对于这个方程，求偏导数可得$\mathcal{w}和\beta$.</p>

<p>$$\frac{\partial{\mathcal{L}}}{\partial{w_i}}=0 ;\quad \frac{\partial{\mathcal{L}}}{\partial \beta_i} = 0 $$</p>

<p>这里，我们谈论的这个约束条件是一个等式。对于更一般的拉格朗日方程，它不但包含等式约束，也有可能报刊不等式约束，也就是<strong>primal</strong> 优化问题。</p>

<p>$$\underset{w}{min}\quad f(w) $$
$$ s.t. \quad g_i(w)\leq 0, \quad i=1,&hellip;,k $$
$$\qquad   h_i(w)=0,\quad i=1,&hellip;l$$</p>

<p>对于更改后的约束，更一般的拉格朗日方程为:</p>

<p>$$\mathcal{L}(\mathcal{w},\alpha,\beta)=f(w)+\sum_{i=l}^{k}\alpha_ig_i(w)+\sum_{i=l}^{l}\beta_ih_i(w)$$</p>

<p>$\alpha与\beta$仍然是拉格朗日乘子。现在考虑拉格朗日方程的最大值，定义其为</p>

<p>$$\theta_\mathcal{P}(w)=\underset{\alpha,\beta:\alpha_{i}\geq 0}{max}\mathcal{L}(w,\alpha,\beta) $$</p>

<p>$\mathcal{P}$代表&#8221;primal&#8221;。拉格朗日方程中，如果选取的 w 出现 $g_i(w)或者h_i(w)$不符合约束条件的话，我们总能够选取足够大的$\alpha和\beta$，使得$\theta_\mathcal{P}(w)$的最大值区域无穷；反之，如果对于任意 w，这些约束条件都满足，则最大值就是f(w),表示如下:</p>

<p>$$
\theta_\mathcal{p}(w) = \left \{
  \begin{array}{l l}
    \infty &amp; \quad \text{如果 w 不满足约束}&#92;
    f(w) &amp; \quad \text{如果 w 满足约束}
  \end{array}
\right.
$$</p>

<p>因此，假设在 w 取值满足约束的时候，如果我们寻找$\underset{w}{min}\theta_\mathcal{P}(w)$，实际上就是寻找$\underset{w}{min} f(w)$。 为什么要绕这个弯子？ 为什么不直接找 f(w)最小值呢？ 那是因为做不到啊，很难用替代法之类的找到这个答案。那么用间接方式又如何做到呢？ 根据上面的推导，我们首先定义</p>

<p>$$\underset{w}{min} \theta_\mathcal{P}(w)=\underset{w}{min} \underset{\alpha,\beta:\alpha_i \geq 0}{max} \mathcal{L}(w,\alpha,\beta) \quad \text {(1)}$$</p>

<p>我们定义这个值为$p^*$。</p>

<p>然后换个角度看待问题，定义新的方程</p>

<p>$$\theta_\mathcal{D}(\alpha,\beta)=\underset{w}{min}\mathcal{L}(w,\alpha,\beta)$$</p>

<p>$\mathcal{D}$代表对偶(dual),这个方程寻找拉格朗日方程的最小值，不过不同于公式(1)中的相对于的变量$\alpha和\beta$，这里我们相对于变量w。继续推导，可得对偶优化问题</p>

<p>$$\underset{\alpha,\beta:\alpha_i \geq 0}{max} \theta_\mathcal{D}(\alpha,\beta)=\underset{\alpha,\beta:\alpha_i \geq 0}{max} \underset{w}{min}\mathcal{L}(w,\alpha,\beta) \quad \text {(2)}$$</p>

<p>这个公式和公式（1）很相似，不同的是把 max 和 min 的顺序反了。定义这个值为$d^*$</p>

<p>不过似乎还是没有头绪，现在不过就是定义了2个公式，对应了两个极值$d^*和p^*$，可这对于解决f(w)有什么帮助呢？答案是这两个值的关系可以帮助我们寻找答案。 那么这两个值什么关系？ 先看一个不等式</p>

<p>$$\underset{x}{max}\underset{y}{min}f_(x,y) &lt;= \underset{y}{min}\underset{x}{max}f(x,y)$$</p>

<p>这个公式这里不证明了，如果想不通可以看一个例子：定义f(x,y)=sin(x+y)，这样可得：</p>

<p>$$\underset{x}{max}\underset{y}{min}f_(x,y) = -1 &lt;= \underset{y}{min}\underset{x}{max}f(x,y) = 1$$</p>

<p>这个公式告诉我们$d^*\leq p^*$。 假设$f,g_i$是凸函数，$h_i(w)=a_i^{T}w+b_i$,同时对于任意w,$g_i(w) \leq 0$，那么必存在$w^*,\alpha^*,\beta^*$，使得$p^*=d^*=\mathcal{L}(w^*,\alpha^*,\beta^*)$ (还不是很明白这一段)，同时$w^*,\alpha^*,\beta^*$符合 KKT 条件（Karush-Kuhn-Tucker)：</p>

<p>$$
\begin{align*}
\frac{\partial{}}{\partial{w_i}}\mathcal{L}(w^*,\alpha^*,\beta^*) &amp;= 0,\quad \text {i=1,..,n} &#92;
\frac{\partial{}}{\partial{\beta_i}}\mathcal{L}(w^*,\alpha^*,\beta^*) &amp;= 0,\quad \text {i=1,..,l} &#92;
\alpha_i^*g_i(w^*)&amp;=0,\quad \text {i=1,..,k} &#92;
g_i(w^*)&amp;\leq 0,\quad \text {i=1,..,k} &#92;
\alpha^*&amp;\geq 0,\quad \text {i=1,..,k}
\end{align*}
$$</p>

<p>未完，待修改&hellip;</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/15/2016-01-15-pythonexp2/">Python 语言使用回顾 (二)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/09/pythonexp/">Python 语言使用回顾</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/24/resume/">Resume</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/04/closures/">闭包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/30/legb/">LEGB规则与 Python 变量的存取</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Wu Li -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'httpwulimobi';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
