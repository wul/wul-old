<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Wu's Blogs]]></title>
  <link href="http://www.wuli.mobi/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.wuli.mobi/"/>
  <updated>2017-05-18T23:31:33+08:00</updated>
  <id>http://www.wuli.mobi/</id>
  <author>
    <name><![CDATA[Wu Li]]></name>
    <email><![CDATA[li.koun@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[闭包]]></title>
    <link href="http://www.wuli.mobi/blog/2015/05/04/closures/"/>
    <updated>2015-05-04T14:27:03+08:00</updated>
    <id>http://www.wuli.mobi/blog/2015/05/04/closures</id>
    <content type="html"><![CDATA[<p>套用维基百科的解释：闭包（closure）是此法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。我们从一个简单地例子来分析这些话在说什么。</p>

<pre><code>def foo(bar):
    def plus_one():
    return bar+1          #1 引用自由变量 bar

    return plus_one
func1 = foo(100)
func2 = foo(101)
print(func1())                #2 bar 仍然存在， 输出为101
print(func2())                #3 bar 仍然存在， 输出为102
</code></pre>

<p>这个例子中，foo 函数中一个局部变量 bar 被一个其内部定义的函数 plus_one 所引用，并且这个函数被当做对象作为返回值返回。当被返回的函数被调用的时候，其运算的时候仍然能够访问得到 foo 所定义的局部变量 bar，即使此时已经不在 foo 函数内部。 这个就是闭包的一个基本用法。</p>

<p>首先确定的是，闭包在创建的时候封闭了当时的一些状态，并且能够此后被调用的时候利用当时的状态信息。上面例子中，诸如局部变量（plus_one的enclosing函数）bar被plus_one所保留，即使离开了 foo 的执行，plus_one 仍够访问这个当初保留的状态，也即 bar 这个变量。</p>

<p>再者，我们看到，根据不同的环境创建的函数保留了不同的状态而在此后表现出不同的行为（输出分别为101和102），比如根据参数不同生成的两个函数 func1和 func2，非常类似模式里面的工厂方法。创建的时候根据不同的输入而此后表现出不同的行为带给程序员很大的灵活性。</p>

<p>最后，在使用闭包的过程中，需要注意，闭包引用的变量可能在后来发生改变，因此也会影响闭包的行为。比如：函数 plus_one 在创建的时候保留了 bar 的状态，但不意味着此后如果 bar 的值再次修改，不会影响 plus_one 的调用结果。修改上面代码如下:</p>

<pre><code>def foo():
    bar = 100                
    def plus_one():
    return bar+1         
bar = 99                 # 在创建plus_one函数对象之后，修改 bar 会影响 plus_one 的调用结果
    return plus_one
func = foo()
print(func())                # 输出100
</code></pre>

<p>可以看到，return 函数对象plus_one之前，修改过 bar 的值，plus_one 的调用使得它会使用最后一次 bar 的赋值。需要注意一下这个特性，尤其是引用的变量处于循环当中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LEGB规则与 Python 变量的存取]]></title>
    <link href="http://www.wuli.mobi/blog/2015/04/30/legb/"/>
    <updated>2015-04-30T16:38:35+08:00</updated>
    <id>http://www.wuli.mobi/blog/2015/04/30/legb</id>
    <content type="html"><![CDATA[<p>每种语言都有检索变量的规则，决定了当程序查找一个变量的时候，会去哪里找，遵循什么样的搜索顺序。Python 亦然，Python 内部的查询变量的规则简称 LEGB。它是 Local，Environment，Global，Builtin 首字母的缩写。</p>

<p>具体说来，加入一个函数要操作一个叫做 x 的变量，那么 Python 首先在函数内部，局部（Local）范围来查找这个变量；如果没有找到，则到包含这个函数定义的外围去查找（称作 Enclosing)，这个外围或许是另外一个函数（包括匿名函数），如果还是没有，继续朝外查找，一直到模块级别，从这里定义了全局（Global）变量中寻找；如果仍然没有找到，则查找 Python 内置变量(Built-in)，看是否有相同名字的。</p>

<p>在上述查找过程中，一旦变量找到，就不再继续朝外围查找。也就是说 LEGB 同时也定义了从 L 到 B 得优先级。根据这个规则，读 Python 程序的时候，就非常容易判断程序到底操作的是哪个变量。比如一个文件 spam.py：</p>

<pre><code>eggs = 5
def func():
    eggs = 4
    def set():
       eggs = 3
       print(eggs)

    set()               #1  print 3
    print(eggs)         #2  print 4

func()
print(eggs)             #3  print 5
</code></pre>

<p>屏幕依次会输出3，4，5.  道理遵循 LEGB 规则，  #1 set()函数里对 eggs 进行赋值操作会产生一个 set 函数的局部变量；#2 因为之前的 set() 操作处理的时 set 函数内部的变量，并不影响 func 定义的变量 eggs，所以这个变量内容不变；#3 同理 func() 函数调用并不影响全局定义的 eggs 变量，所以打印的全局变量值仍然是5.</p>

<p>从上面的操作及对变量的影响来看，LEGB 规则确实起到作用，变量的查找遵循由内而外的原则。由内到外的指的是 Local->Enclosing->Global->Built-in</p>

<pre><code>--------------------------------------------------------------
|Built-in(Python):                                           |
|    Python 内置的一些预先定义的名字：包括 open ，Exception 等。   |
|    --------------------------------------------------------|
|    |Global(Module):                                        |
|    |    模块文件最外面定义的变量名，属于模块的变量                | 
|    |    ---------------------------------------------------|
|    |    |Enclosing                                         |
|    |    |    定义在外层包含函数里的名字                        |
|    |    |    ----------------------------------------------|
|    |    |    |Local                                        |
|    |    |    |    函数内部所定义的变量                        |
--------------------------------------------------------------
</code></pre>

<p>那么，如果在函数内部想特意使用外面的变量，而不是产生一个新变量，又如何做呢？ Python 提供两个语句，global 和 nonlocal 来声明外围的变量，而不是在函数内部产生一个同名的局部变量。举例如下：</p>

<pre><code>eggs = 5
def func():
    global eggs
    eggs = 4

hams = 10
    def set():
    nonlocal hams
        hams = 99

    set()               
    print(eggs)         #1  print 4
    print(hams)         #2  print 99


func()
print(eggs)             #3  print 4
</code></pre>

<p>此时屏幕输出4,99,4。 #1输出为4原因显而易见；#2输出99是因为 set()函数调用使用 nonlocal 声明，表示改变的 hams 变量是外围 func()函数内部所定义的变量；#3则是因为 func()调用声明 eggs 是全局变量，进而修改了这个变量的值。</p>

<p>需要注意的是global 与 nonlocal 声明的用法。一个声明了变量属于 module（全局的），一个声明了变量属于外围的（上级函数）。如果在 func（）内部的语句“global eggs”变成“nonlocal eggs”则会引起语法错误，因为 eggs 是个全局变量，使用前需要 global 来声明。</p>

<p>到了这里，我们可以自认为了解了Python如何查询，修改变量。基本上如此，对于一般声明的变量是这个规则。但是对于有些变量，他们的声明作用域比较特殊，需要区别对待，依旧举例说明：</p>

<pre><code>x = 100
lst = [1,2,3]
lst2 = [x for x in lst]
print(x)                   #1 still 100

try:
    1/0
except Exception as x:
    pass

print(x)                   #2 UnboundLocalError: local variable 'x' referenced before assignment
</code></pre>

<p>上面的例子中，注意变量 x，除过普通用法，它还用作在另外两个地方</p>

<ul>
<li><p>Comprehansion 变量:</p>

<p>诸如[x for x in lst]里的x，这里定义的这种变量，它的作用域只是这个表达式，Python 3.x之后放置这些变量与其他变量的冲突，修改其作用域到表达式内部。</p></li>
<li><p>Exception 变量： 诸如 &ldquo;Exception as x&rdquo;, 一旦异常被捕获，x 就用来被存放异常对象，<strong>并且在异常处理 excpt 语句结束后被删除！</strong>, 因此之后的 print(x)会报错！</p></li>
</ul>


<p>当然了，如果你仔细维护你的代码，并且遵循 LEGB 规则，你就不会起名同名变量来做类似操作，因此即使你不知道这两种特殊作用域的变量也没有关系。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 包管理以及导入包时候一些问题辨析]]></title>
    <link href="http://www.wuli.mobi/blog/2015/04/29/issues-of-imports/"/>
    <updated>2015-04-29T14:16:39+08:00</updated>
    <id>http://www.wuli.mobi/blog/2015/04/29/issues-of-imports</id>
    <content type="html"><![CDATA[<p>之前写了一点关于Python相对包导入机制的东西。除过概念上要区分传统导入方式，记住包导入时候如何寻找路径之外。还经常会碰见在包管理以及使用上因为随意混合这两种方式所带来的意想不到的后果。</p>

<p>之前说过，对于传统包引用：</p>

<pre><code>import foo
</code></pre>

<p>Python2.x和Python3.x对其的解释是不同的。</p>

<ul>
<li>Python2.x: 寻找当前路径（CWD），然后系统路径</li>
<li>Python3.x: 只查找系统路径</li>
</ul>


<p>那么，加入我们有一个包&#8221;foo&#8221;，其内部模块如下:</p>

<pre><code>foo \
    __init__.py
    main.py
    bar.py
    baz.py
</code></pre>

<p>其中, main是一个主程序，也放在这个包中，内容如下：</p>

<pre><code>import bar
</code></pre>

<p>bar.py内容只有一行，就是加载 baz 包:</p>

<pre><code>import baz
</code></pre>

<p>baz内容略过，不重要。那么我们运行如下命令</p>

<pre><code>python foo/main.py
</code></pre>

<p>无论对于Python2.x和Python3.x，结果都正常，很和谐，没有错误。这是因为无论从相对路径中还是系统绝对路径中， 主程序 main.py 所在的目录都在其中，所以 python3.x 和 python2.x 都能正常工作。但是如果 main.py 不在 foo 目录下面，将其内容修改为<strong>import foo.baz</strong>，如其下所示:</p>

<pre><code>main.py
foo \
    __init__.py
    bar.py
    baz.py
</code></pre>

<p>那么运行python3 main.py会出现异常&#8221;ImportError: No module named &lsquo;baz&rsquo; &ldquo;，这是因为python3.x 只会在系统目录下查找 baz 模块，而系统目录只是一组包含主文件程序文件 main.py 所在目录的列表，里面并不包含baz这个模块。 要解决这个问题，唯有把 foo 所在的目录写入到 sys.path 中去（手工写入或者通过 PYTHONPATH 环境变量）</p>

<p>关于传统的 import mod 语句，重点在于：<strong>在 Python3.x 下，如果工作于包管理模式下，则不会从mod.py 所在目录下查找 mod 模块（除非这个目录被用各种方式加入到 sys.path 中去）</strong></p>

<p>那么对于相对导入 from . import mod 这种语句，我们知道它是用来在包内各个模块至今互相引用的。它的初衷服务于包管理。我们仍然使用包含main.py的最初例子, 这个时候不管 Python2.x还是Python3.x在运行 main.py 主程序的时候都会抛关于无法相对导入模块的异常。Python 不允许你在使用相对导入这种包管理的时候把包的目录当做程序目录。你必须要吧 main.py 从包内部拿出来，比如放在 foo 所在的同级目录下。为什么？ 不清楚。</p>

<p>重点在于，<strong>如果你使用了相对导入，那么就需要将包内部的目录层次完全当做包来使用，不要混合程序文件在其中</strong>。</p>

<p>如果想使用相对导入模式，你会碰到更大麻烦。比如对于包内的模块 bar.py, baz.py， 我怎么在这些文件中加入 unittest，并把这些 module 文件当做程序文件来进行单元测试呢，这可是最好的放 unittest 的地方啊？ 这是一个好问题。</p>

<p>答案是可以用传统的包导入方式来解决。 什么？ 又回去了！！！ 我也不想啊，Python 看到这里我也想找个人抽一抽，费劲理解这么多概念，一会碰到这个问题一会碰到那个问题，最后来还是用老方式好。 这里一点都不 Pythonic。</p>

<p>抱怨归抱怨，如何解决让包内的文件同时可以当做程序文件来执行呢。 举个例子，对于 bar.py，我们使用</p>

<pre><code>from foo import baz
</code></pre>

<p> 一方面可以解决相对导入模式下无法当做程序文件使用；另外一方面可以解决不小心在 sys.path 下找到一个同名的 baz 文件而导入错的事情。当然了，代价就是敲的字符多了，当初从 import baz 到相对导入 from . import baz， 现在时 from foo import baz， baz 如果层次越深敲得越多。</p>

<p>似乎使用绝对导入能够使用的范围更为广泛。那么为什么要存在相对导入这种奇葩呢？他们说，能够解决一个层次复杂的 package 重新组织时候需要修改各个包的麻烦。 我相信这是对的，不过我也相信相对导入带来的麻烦更多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Relative Imports]]></title>
    <link href="http://www.wuli.mobi/blog/2015/04/22/python-relative-imports/"/>
    <updated>2015-04-22T10:11:17+08:00</updated>
    <id>http://www.wuli.mobi/blog/2015/04/22/python-relative-imports</id>
    <content type="html"><![CDATA[<h1>Python Relative Imports</h1>

<p>Python包内模块之间当然可以像我们熟知的包导入方式一样，通过<em>import</em>或者<em>from &hellip; import &hellip;</em>来完成。 但是这里有个细节问题，可能会出现并非开发者所想到的后果。通过举例来说明， 现在要开发一个包（Package）Hello，它的目录结构如下：</p>

<pre><code>Hello\
      __init__.py
      foo.py
      bar.py  
</code></pre>

<p>Hello这个包包含两个文件， foo.py 和 bar.py， 我们说 foo.py 包含一个函数叫做 <em>func</em>，bar.py 希望通过引入 foo 这个包来使用这个函数。那么对于 bar.py 来讲，导入并使用的方式可以如下：</p>

<pre><code>import foo
foo.func()
</code></pre>

<p>这个用法似乎也没啥问题。 但是Python2.x 与 Python3.x 对于<em>import foo</em>的解释是不同的。</p>

<ul>
<li>Python2.x:会在当前包（&#8221;Hello&#8221;）所在的路径中搜索叫做 foo 的包名，然后搜索系统路径(sys.path)</li>
<li>Python3.x:只会搜索系统路径</li>
</ul>


<p>可以看到，对于一些程序，如果既要运行在 Python2.x，又要运行到 Python3.x，可能会出现问题，考虑到 sys.path 里面的目录，其中一个路径恰好也有一个模块是 foo，那么在 bar.py 引入 foo 模块的时候，Python3.x 会用这个模块而非和 bar 在同一个包得模块 foo，当调用<em>foo.func()</em>要么报错（不存在），要么用得不是期望的函数。</p>

<p>那么如何通过显示的手段来指明我们想要引入的包，来避免模块内包互相导入呢出现的上述问题呢？ 这可以使用 Python 的相对导入（Relative Imports）机制。 通过</p>

<ul>
<li><strong>from .foo import func</strong></li>
<li><strong>from . import foo</strong></li>
</ul>


<p>来对包 foo 进行导入。 这种通过一个点来指明包内导入的方式叫做相对导入。</p>

<p>无论是Python2.x或者Python3.x碰见这种语句，都会只在当前包目录中查找想要导入的包，而不会去系统路径中去寻找，因此避免了不当导入。</p>

<p>当然，包得层次结构也不都一定是扁平的，只有一个目录，可能有子目录，子目录下可能还有下级子目录。那么又如何在包内导入其他目录下的模块呢？</p>

<p>有人或许已经猜到，既然像 Unix 访问目录一样，用 “.”表示包内同一个目录。那么可以用“..”表示包层次结构中的上一层。仍旧通过举例说明，有一个复杂的目录结构如下：</p>

<pre><code>Hello \
      __init__.py
      a\
        __init__.py
        b\
          __init__.py
          b1.py
      c\
         __init__.py
         c1.py
</code></pre>

<p>Hello包包含子目录“a”和子目录“c”，其中子目录 “a”又包含二级子目录 “b”。 在目录“b”与“c”内分别有两个模块“b1”与“c1”。模块“c1”想使用“b1”中的函数“func”。</p>

<p>模块“c1”中可以用下面这种方式来引入模块“b1”.</p>

<ul>
<li><em>from ..b.b1 import func</em></li>
<li><em>import ..b.b1</em></li>
</ul>


<p>如同目录行为一样，很好理解，不用赘述。</p>

<p>可是，仍旧有人会说，其实也简单，将 Hello 包所在路径加入 sys.path 中，在模块“c1”中用如下语句也可以：</p>

<pre><code>from Hello.a.b.b1 import func
#
#or
#
import Hello.a.b.b1
</code></pre>

<p>是的，这种方式也可以。但首先，如果目录层次比较复杂，敲的字符会很长，不够经济；再者，如果目录进行挪动，需要改动代码，相对导入能够解决这个问题（相对路径如果保持不变）。</p>

<p>虽然用类似目录结构的方式相对导入包内的模块，但这种语句也只是适合包内导入，位于非包这种组织形式(包含__init__.py)的两个文件，不可以通过这种方式（from . .. import）来互相导入。</p>

<p>总结一下：Python 的相对导入的关键在于</p>

<ul>
<li>它限定了搜索的路径在于包内，而不会盲目的在系统路径中找寻一个相同的名字，避免了误导入。</li>
<li>所有的相对导入通过<em>from &hellip; import &hellip;</em>这种格式来完成</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unicode 以及如何使用 Unicode 编程]]></title>
    <link href="http://www.wuli.mobi/blog/2015/04/07/unicode/"/>
    <updated>2015-04-07T11:07:36+08:00</updated>
    <id>http://www.wuli.mobi/blog/2015/04/07/unicode</id>
    <content type="html"><![CDATA[<p>我们讨论 Unicode和使用编程中使用 Unicode，需要对 Unicode 的一些概念予以澄清，从而知道知道它是什么，它用来解决什么问题。对于很多的程序员来讲，在编程生涯中或多或少听过或者少量用过 Unicode，但是可能对于说清楚它是什么，它如何工作的却没有信心。那么本着回答这些问题的原则，我们来目的性的了解 Unicode 是什么，如何在编程语言中使用（Python）它。</p>

<h1>Unicode的历史起源</h1>

<p>Unicode 的起源源自计算机发展过程中，对于解决多国文字的表示，存储这一问题。</p>

<p>计算机发展初期，并没有这个问题，原因在于，当时的体系结果只处理英文字符即可。这个时候使用的字符集称作 ASCII 码。它将33个控制字符，95个可打印字符的每一个赋予一个7比特的数字。比如，这里面包括了常用的控制键 TAB, \r, \n，数字0-9， 字母A-Za-z等。 这128个字符，用了一个字节的低7位即可表示。对于那个时期的计算机而言足够了，既没有如现在 Mac OSX，Windows 等一样富有表现力的图形界面，也不需要字符界面上做各种花样输出。</p>

<p>当计算机被使用的越来越广泛，越来越多的国家参与到计算机的使用与开发时候，一个新问题马上就浮现出来，那就是对于本国语言的表示示与存储的支持。之前提到的 ASCII 编码集合规定了英文字符用于交互时候的表示，它是通过一个7bit 的数字来表示。那么对于其他的西欧字符，比如字符&#8221;ä&#8221;就无法映射到0-127这个数值范围内。于是有了扩展 ASCII 的 ISO-8859-1(Lantin-1)字符集。Latin-1字符集用到了其他的一些西欧字符，未能能够对其编码，需要把一个字节的8个比特都用到，于是除过 ASCII 定义好的0-127这个数值范围对应的字符外，扩展了128-255的映射，里面包含了诸如ä之类的额外的西欧字符。如下图所示：摘自 <a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1">Wikipedia</a></p>

<p><img src="/images/latin-1.png" alt="LATIN-1" /></p>

<p>到了这里还不够，即使 LATIN-1这种编码仍然没法包含地球上所有国家所使用的字符，也无法包含常用的诸如汉语这样的字符。因此还的定义更多的字符集。</p>

<p>使用中文来举例子，一些常用的简体汉字最初被收纳在 GB2312这个字符集中。GB2312也定义了这些常用汉字的编码，即其对应的数值，这个数值包含着2个字节组成的数字中，被称作区位码。单单从2个字节可以存放的空间来看，能够定义65536个字符，但是实际上对于 GB2312来讲，它只是用到了其中的一部分。按照相关规范的定义，只是用到了其中的一部分，用来编码简体汉字字符。对于包含更多汉的字字符集，有 GBK，GB18030标准。</p>

<p>选用不同的编码标准，即使对于同一个字符，可能也有不同的编码。比如字符&#8221;ä&#8221;在cp857（Turkish） 编码中值是132，但在 Latin-1中是228, 在UTF8中则是0xc3a4。代码页(code page)是字符编码的别名，是特定语言字符集的一张表。这张表描述了可支持的字符的集合及其编码。 由于历史原因，Microsoft，IBM，SAP 等都定义了自己的代码页，同一种编码比如“utf-8&#8221;在 Windows中代码页是1208，微软是65001，SAP 是4110，显得很混乱。不过这都是历史原因了。目前我们要关注的是 Unicode，以及 Unicode 在内存中和以及传输、存储中的表示。</p>

<p>因此围绕各国语言定义了很多字符集，同时定义了这些字符集如何编码（转换成数字的值）。但是仍然不够，如果选取某种字符集及编码方式，一般只能做到同时支持拉丁字符和选取的字符集（比如简体汉字），无法同时支持诸如中文、韩语、阿拉伯文。因此，出现了由非盈利组织<em>统一码联盟</em>负值推广的 Unicode 字符编码方案，旨在赋予每个字符（任何语言）对应一唯一数值的方式来替代现有的字符编码方案。</p>

<p>Unicode 将不同语言中的字符统一编码。其赋予任何语言，任何字符一个唯一的一个值，称作 code point，这个值得范围是 U+0000到 U+10FFFF, 理论上映射1,114,112个字符。因此从空间上来看是够了。</p>

<h1>字符集，Unicode, Coding, Encoding等概念辨析</h1>

<p>前面说了 Unicode 及其以前关于字符编码的一些基本知识。我们基本可以得到一个概念，这么多年来我们实际上面临了一个文字由人传递给机器的一个问题。那就是，如何让计算机表示人类的字符，并且消除发展过程中形成的“局域”化的标准，转向“统一”标准。</p>

<p>注意，Unicode 只是定义了一个更庞大的字符集，并且把其中的每个字符与一个数字对应起来。但是并没有定义如何存储这些数字，比如汉字的“汉”，对应的 code point 值是 u+6c49, 这个值两个字节，Unicode 并没有说它存储成文件是否应该存贮成&#8221;6c49&#8221;这种16进制串或者存贮成一个短整数 6c49，如果考虑到 Little Endian 或者 Big Endian 还要考虑顺序。因此，如果考虑到存储，这里还要进行再次的编码。</p>

<p>让我们对编码（Encoding）这个概念进行一下澄清。之前将到字符集以及如何将字符“编码”成数字，是建立一个概念上的字符与数字之间的意义对应关系。这里并不牵扯到这个数字如何表示，在计算机中用几个字节存储，字节顺序等等。它只一个概念上的字符与数字的对应。这里的编码（Encoding）是抽象层次的编码，准确说来是 “编号”（Coding）；而如果考虑这些数字的最终存储形式等实现细节，则是实现层次的编码,比如 UTF-8, UTF-16, UTF-32.  这里举的例子针对 Unicode。对于简单地ASCII 码，它既是指ASCII 字符的编号，同时也是编码。编码这个概念在 Unicode 相关概念中实在是重要，因此需要理解在提到编码的时候到底指的是哪个层次的编码。</p>

<p>使用图例来区分 编号（Coding） 与 编码（Encoding）之间的区别。他们所在的层次不一样，如下面所示。
<img src="/images/encoding.png" alt="Coding/Encoding" /></p>

<p>一个某种语言的字符，首先对应一个某种规则定义的数值。这是用来定义某种字符集和它的编号规则。然后，在存储的时候，这个编号根据不同的编码规则，生成二进制序列串（比如 Unicode 字符‘汉’按照不同编码规则生成的字节流不一样）。实际上在看关于 Unicode 相关文章的时候，编号和编码这两个词是混用的，但是我们自己心里得清楚这里有两个层次： 一个是数字表示形式，一个是数字存储形式。</p>

<p>因为我们之后要重点关注 Unicode 字符串的处理，而UTF-8编码使用的比较多，我们这里对 UTF-8编码规则做一个介绍：
UTF-8具体的编码方式</p>

<blockquote><ul>
<li>code point 为0-127的（ASCII）编码成一个字节。</li>
<li>128-255的编码成2个字节。</li>
<li>大于0x7ff 的编码成3-4个字节。</li>
</ul>
</blockquote>

<p>当然了，你也可以在存储Unicode 字符串的时候选择 UTF-16方式。那么别人拿到这个文件，他如何得知以什么方式打开这个文件，或者说如何解码呢？
这里有个 BOM（Byte Order Mark）这个概念，在文件的头部，有一些特殊字符，来表明这个文件存储的时候以什么方式编码的。比如文件头碰到“EF BB BF”我们可以得知这个文件是 UTF-8编码，碰见“FE FF”可以得知这个事以 UTF-16进行编码的。完整的列表可以参考<a href="http://en.wikipedia.org/wiki/Byte_order_mark%20Wikipedia">Wikipedia</a></p>

<h1>操作系统的支持</h1>

<p>常用的操作系统 Windows，Linux，Mac OSX都已经支持 Unicode</p>

<h1>编程语言的支持</h1>

<p>Unicode 字符集赋予任意一个字符一个唯一的值。那么我们平常书写的程序中，使用字符串的时候，这些字符串在内存中如何表示呢？对于早期用 ASCII 码字符串，这个问题很好理解。比如对于 C 语言处理 ASCII 字符串，我们一般是在内存中生成一个字节数组，用来存储字符串对应的 ASCII 值，最后用0来结尾。到了 Unicode 时代，我们知道一个字节肯定不行了，那么对于Unicode 字符串，有的语言比如 Python 是在内存中存放这些字符对应的 code points，对于字符串的一些操作如索引，分割，拼接也就是对这些 code points 做相应的动作。最后这些字符串如果想要传输或者存储，则先用诸如 UTF-8, UTF-16等编码然后再处理。</p>

<h1>使用 Python 和 Unicode</h1>

<p>在 Python，尤其是 Python 3.X 中处理 Unicode 字符串异常的方便。我们通过一些例子来了解关于 Unicode 字符串的一些处理。</p>

<h2>普通字符串操作</h2>

<p>声明Unicode字符串，在 Python3中，所有的字符串都是 Unicode 字符串，所以你只要如下面声明一个字符串，那就已经是一个 Unicode 字符串了</p>

<pre><code>s = '汉字'
</code></pre>

<p>那么它的长度呢</p>

<pre><code>len(s)                                 =&gt; 2
</code></pre>

<p>完美，并不会出现奇怪的长度居然是4，6啊之类的怪异数字，2个字符就是2个字符，不管它们是什么语言的字符</p>

<p>那么对于一些字符，或许我们键盘没有输入法，但是我知道它的 code point，如何输入呢？</p>

<pre><code>s = '\u6c49\u5b57'                  =&gt; '汉字'
</code></pre>

<p>使用<em>\uNNNN</em>或者<em>\UNNNNNNNN</em>这种方式可以从 code points 来生成 Unicode 字符串。</p>

<p>显式的对 Unicode 字符串进行编码会生成字节数组，参数 encoding 可以选择任何支持的编码方式，大约有100多种，可以参考Python 库手册所定义的编码方式<a href="https://docs.python.org/3/library/codecs.html#standard-encodings%20Standard%20Encodings">Standard Encodings</a>. encode、decode 方法的缺省编码都是 utf8。</p>

<pre><code>s.encode(encoding='utf8')             =&gt; b'\xe6\xb1\x89\xe5\xad\x97'
</code></pre>

<p>从字节数组解码生成字符串对象</p>

<pre><code>b = s.encode(encoding='utf8')
s = b.decode(encoding='utf8')             =&gt;'汉字'
</code></pre>

<p>另外一种字符串对象与字节数组转换的方式</p>

<pre><code>b = bytearray(s, 'utf8')      =&gt;b'\xe6\xb1\x89\xe5\xad\x97'
s = str(b, 'utf8')                 =&gt;'汉字'
</code></pre>

<p>注意在这个例子中，encoding 不再是字典参数，encoding 参数也没有缺省值，如果不提供的话，可能出现不适期望的结果， 比如</p>

<pre><code>b = b'abc'
s = str(b)                =&gt;"b'abc'"
</code></pre>

<p>字符串并未还原成&#8217;abc&#8217;，而是生成字符串&#8221;b&#8217;abc&#8217;&#8221;</p>

<h2>源文件字符集编码声明</h2>

<p>在写 Python 程序的时候，源文件本身可能含有多国语言，甚至源文件中一些变量名，函数名本身也支持多国语言（Python 支持），比如声明一个变量如下：</p>

<pre><code>变量 = 100
</code></pre>

<p>以中文名定义了一个变量。  这些由非全 ASCII 码构成的源文件本身在存储到硬盘的时候，也需要进行编码。 因此 Python 解释器需要知道在加载这些源文件进行执行的时候，首先要能够读取构成程序的代码字符串。Python 在文件头的注释里面，可以添加如下定义：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: &lt;encoding name&gt; -*-
</code></pre>

<p>或者</p>

<pre><code>#!/usr/bin/env python
# coding: &lt;encoding name&gt;
</code></pre>

<p>来指明。</p>

<h2>文件操作</h2>

<p>文件处理操作的模式有两种，文本模式与二进制模式。对于将 utf8格式的文件来说，可以将其看做是文本文件，也可以将其看做是二进制文件。只是在读取其内容还原成字符串对象的时候步骤不同。</p>

<p>首先考虑文本方式，Python3.x 提供的 open 函数增加了一个 encoding 参数，用户当以文本方式打开文件的时候，将会以此参数指定的编码方式来进行编解码。这个过程对于调用者来讲是透明的，自动的。通过 read(), readlines()之类的结果，读取的结果是字符串对象。通过 write(), writelines()接口写入的时候，Python 会自动进行字符串的编码，想字节数组写入文件中。</p>

<pre><code>s = "这是 unicode 字符串"
with open("unicode.txt", 'w', encoding='utf8') as outf:            
    outf.write(s)
with open("unicode.txt", 'r') as inf:                    #缺省以 utf8方式打开
    s = inf.readline()
print(s)                                                 =&gt; "这是 unicode 字符串"
</code></pre>

<p>如果以二进制方式打开的话，那么写入和读取文件都是字节数组。这些字节数组在写入的时候需要调用者调用 encode 方法显式地生成，或者读取的时候使用 decode 方法显式地解码。</p>

<pre><code>s = "这是 unicode 字符串"
with open("unicode.txt", 'wb') as outf:
    outf.write(s.encoding())                        #手工编码
with open("unicode.txt", 'rb') as inf:
    b = inf.read()
s = b.decode(encoding='utf8')                       #手工解码
print(s)                                             =&gt; "这是 unicode 字符串"
</code></pre>

<p>到此，基本上应该明白了啥是 Unicode，基本原理是什么以及如何在 Python 中使用。其他的一些语言如 Java, C++没有经验，不知道是否如此方便的处理 Unicode，但是网上搜到的关于 C++关于处理 Unicode 的一些例子，在解决 Unicode 字符串的 Indexing、slicing 以及可移植性上似乎很是麻烦，我不禁陷入了深深的沉思，这种面向内存编程的语言，真是让程序员过多的考虑构建合适的辅助工具而不能专注于要解决的业务问题。面对日新月异的互联网时代，这些语言何去何从呢？</p>

<p><b><img src="http://img.blog.csdn.net/20141031165003296" alt="装B 状-pic from CSDN" /> </b>
<b><a href="http://img.blog.csdn.net/20141031165003296">装B 状-pic 引用自 CSDN</a></b></p>
]]></content>
  </entry>
  
</feed>
