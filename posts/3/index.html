
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Wu's Blogs</title>
  <meta name="author" content="Wu Li">

  
  <meta name="description" content="装饰（Decoration） Decoration 是一种向函数或者类添加代码或者进行管理的方式。在Python中，我们是通过使用装饰器来实现这种管理或者代码注入的。 装饰器（Decorator） 装饰器 (Decorator) 本身也是callable对象（函数或类）, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.wuli.mobi/posts/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Wu's Blogs" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Wu's Blogs</a></h1>
  
    <h2>A blog for saving my articles.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.wuli.mobi" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/21/python-decorator/">Python Decorator</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-01-21T00:00:00+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>装饰（Decoration）</h1>

<p>Decoration 是一种向函数或者类添加代码或者进行管理的方式。在Python中，我们是通过使用装饰器来实现这种管理或者代码注入的。</p>

<h1>装饰器（Decorator）</h1>

<p>装饰器 (Decorator) 本身也是callable对象（函数或类）,其处理callable对象并返回callable对象（要理解好下文的概念，一定要理解callable对象，有关callable 的概念请参考 Python手册 ）。 按照被装饰对象分类可以分为</p>

<ul>
<li> Function Decorator 对函数进行装饰，提供函数的管理</li>
<li> Class Decorator 用来对类进行装饰，对类及其类的实例进行管理</li>
</ul>


<p>无论对类还是对函数进行装饰，其实质都是在函数或者类的定义之后添加了一些代码。至于这些添加的代码，则可以完成各种任务。比如：</p>

<p>用来代理函数调用：通过安装wrapper函数，使得对函数的调用先经过添加的代码，执行一些处理，然后才将执行传递给原先被装饰的函数。
用来接口代理：对类进行代理，使得类实例的创建接口被代理。可以先经过添加的代码执行一些处理，然后调用原先的类创建函数，使得最后被创建的实例能够被管理。
装饰的原理和过程如下：</p>

<p>在函数定义(def)或者类定义(class)之后，装饰器先对原先的函数或者类添加一些处理。
装饰器将处wrapper函数或者原函数或类或者类重新赋值回原先的函数或者类名。
当调用者使用这些callable的函数和类的时候，它实际上调用的是被装饰过的，与先前函数或者类有相同名字的callable而已。至于这些装饰过的函数具体做些什么，则完全看装饰器的目的如何。
为什么需要装饰器呢？因为在实际变成中，我们可能需要处理以下场景：</p>

<p>对函数进行日志，跟踪，调试，timing，锁处理等。
对类及其属性进行跟踪，验证等。
对这些的处理可以手工来做，但是使用装饰器有两个好处：</p>

<p>显式语法：使得处理的意图明确，比如@classmethod,@property,@staticmethod等。
一次定义，到处使用：因为wrapping的方式都是一样的，因此装饰器可以定义后用在任何使用这些代码的地方，不用到处拷贝代码。</p>

<h1>使用装饰器</h1>

<p>在定义自己的装饰器之前，先看一些使用装饰器的例子，来理解装饰器怎么用，它揭示了些什么秘密。</p>

<ul>
<li><p>函数装饰器:
函数装饰器作用在函数上，包括普通函数和类的成员函数。用在函数定义语句def之前。</p>

<pre><code>#对函数进行装饰
@decorator
def func (*args):
    ...
</code></pre>

<p>调用被装饰的函数</p>

<pre><code>func(1,2,3)
</code></pre>

<p>其本质是对函数增加了代码并对函数名字的重绑定</p>

<pre><code>def func (*args):
    ...

func = decorator(func)
</code></pre>

<p>decorator就像是一个高阶函数，对函数进行加工处理，因此调用时候实际上调用 func(1,2,3) 就是</p>

<pre><code>decorator(func)(1,2,3)
</code></pre>

<p>不单对于普通函数可以应用装饰器，对于类函数亦可以。可以参考@classmethod, @staticmethod, @property</p></li>
<li><p>类装饰器</p>

<p>类装饰器作用在类上。用在类定义语句class之前。</p>

<pre><code>#对类进行装饰
@decorator
class Cls:
    ...
</code></pre>

<p>使用被装饰的类</p>

<pre><code>ins = Cls()
</code></pre>

<p>实际发生的是Cls = decorator(Cls)，Cls实际上变成另外一个改装的类。代码ins=Cls()实际上是ins=decorator(Cls)()，因此看起来生成的实例ins实际上是被装饰类的返回callable对象调用的结果。这个callable可以是一个被装饰后的类，也有可能是一个函数而已，完全看装饰器是如何实现的。但是最终的结果是生成了一个callable对象ins.一个 正常 的装饰器应该允许此ins实例调用其实例方法，属性，除过装饰作用，应该保留被装饰类的特性，让用户用起来能够保持其原先的语义。</p></li>
</ul>


<h1>实现装饰器</h1>

<p>装饰器本身就是callable对象，因此可以用以下两种方式来实现装饰器</p>

<ul>
<li><p>通过函数来实现装饰</p>

<p>最常用和易于理解的实现方式。通过定义一个函数，其加工callable对象，并返回callable对象。比如要对一个callable对象进行装饰，可以通过函数来先定义一个装饰器如下：</p>

<pre><code>def decorator1(f):
    #added a lot of code here
    ...
    #finally, you return original f
    return f

def decorator2(f)
    #added a lot of code here
    ...
    #and you defined a wrapper
    def wrapper_of_f(*args):
        #some code 
        ...
        #execute original callable
        f(*args)

    #finally, you return a wapper of f
    return wrapper_of_f
    ... 
</code></pre>

<p>decorator1仅仅在你定义完毕callable的时候增添了些代码，或者用来管理记录，或者用来调试等，它将用户定义的函数重新赋值给原先的函数名。decorator2则安装了一个代理函数，并将其返回，当你使用调用callable对象的时候，实际上已经不是执行原先的函数，而是这个代理函数了。</p></li>
<li><p>通过类来实现对象</p>

<p>一个类通过实现<em>call</em>方法可以使其变成一个callable对象。借助于这个特性，可以用类来实现装饰器。</p>

<pre><code>class decorator:
    def __init__(self, f):
        self.f = f
        #add your code here
        ...

    def __call__(self, *args):
        #add your code here
        ...
        #then call original callable
        self.f(args)
</code></pre>

<p>通过用类实现的装饰器与用函数实现的装饰器原理类似。对于最初的一个callable，比如foo。首先，在对其装饰的时候</p>

<pre><code>@decorator
def foo(*args):
    ...
</code></pre>

<p>会生成一个decorator类的实例，这个实例存有变量self.f，指向原先的foo。这个decorator的实例会被重新绑定到名字foo上。因此之后调用foo其实是调用decorator的实例，由于这个实例实现了&#8221;<em>call__&ldquo;方法（实例是个callable对象），使得实例的调用即为&#8221;decorator.</em>call__&#8221;的调用.</p></li>
</ul>


<p>需要注意的是，用类来实现装饰器的时候，如果被装饰的callable是个类成员函数的话，会引起副作用。接着用上面的例子，如果foo是一个类Cls的成员函数，如下定义并使用装饰器:</p>

<pre><code>class decorator:
    def __init__(self, f):
        self.f = f

    def __call__(self, *args):
        print self
        self.f(args)

class Cls:
    @decorator
    def foo(self, data):
        print data
</code></pre>

<p>那么我们调用的如下代码的时候</p>

<pre><code>ins = Cls()
ins.foo("hi")   #call ins.
</code></pre>

<p>存成/tmp/decorator.py并执行以上代码，输出为</p>

<pre><code>&lt;__main__.decorator instance at 0x108793560&gt;
Traceback (most recent call last):
  File "/tmp/decorator.py", line 16, in &lt;module&gt;
    ins.foo("hi")
  File "/tmp/decorator.py", line 7, in __call__
    self.f(args)
TypeError: foo() takes exactly 2 arguments (1 given)
</code></pre>

<p>ins.foo()调用实际上调用的是decorator的实例，这个实例有&#8221;<em>call__&ldquo;方法，是个callable对象，因此会最终执行到&#8221;decorator.</em>call__&#8221;中的self.f,这才是最初定义的Cls的成员函数。但是此时遗憾的是，在装饰器调用它的时候，已经丢失了实例对象，self无法被替换成Cls的实例ins。 如果用函数来实现装饰器的话则没有这个问题，如下:</p>

<pre><code>def decorator(f):
    def wrapper(*args):
        print "inside wrapper"
        f(*args)

    return wrapper

class Cls:
    @decorator
    def foo(self, data):
        print data
</code></pre>

<p>输出为</p>

<pre><code>inside wrapper
hi
</code></pre>

<p>实际上调用代理方法wrapper的时候，实例ins作为第一个参数，这些参数会原封不动的继续传递给wrapper中的f（即Cls的foo）</p>

<h1>总结</h1>

<p>装饰器的实际上就是一个callable对象，通过在函数或者类定义之后增加一些代码装饰另外一些callable（类或函数），并且返回经过装饰的callable（类或函数），来达到一些特殊目的。</p>

<p>最后，感谢emacs orgmode，最近发现了这个好东西，在emacs直接写文本，自动转换成html，方便了许多。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/02/emacs-packages/">Emacs Package Management</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-01-02T00:00:00+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Emacs has a powerful pacakge management system &ldquo;pacakge.el&rdquo;. Normally you need a few lines of modification of .emacs and restart the Emacs, the packages you wanted will be auto-loaded for you. Of course, like other convinent package management systems such as &ldquo;apt-get&rdquo;, &ldquo;yum&rdquo;, &ldquo;quickload&rdquo;, you need internet access.</p>

<h1>Make Emacs Manage Packages</h1>

<ul>
<li><p>Configure .emacs file</p>

<p>In .emacs file, put below lisp forms</p>

<pre><code>(require 'package)
(package-initialize)
(add-to-list 'package-archives
      '("marmalade" . "http://marmalade-repo.org/packages/"))
</code></pre>

<p>These direct emacs to do auto package initialization when startup. The package-archives varaible saves all package repository list. There are some repository maintained by different orgs. Google them for yourself.</p></li>
<li><p>Restart Emacs</p>

<p>After restarting Emacs, type &rsquo;M-x&#8217; and input list-packages, Emacs will open a new buff that displays all available pckages. The package source is what you just configured before.</p>

<p>In this buffer, you can browse the packages use emacs search shortcut to find wanted packages, you also can use shotcuts to mark/unamrk the package you install/uninstall. Getting the key and command list by typing M-x and input describe mode or get the description here. For impatients, just use &lsquo;Up&rsquo;/&lsquo;Down&rsquo; key to navigate to the package and click &lsquo;Enter&rsquo; key to install them.</p></li>
<li><p>Auto Load Packages When Emacs Starting Up</p>

<p>Added below Lisp forms into your .emacs file</p>

<pre><code>(defvar  package-list
   '(djvu
     oauth2)
   "List of package need to be installed")
#Check if the package is there, if not, downloading/installing/loading
(dolist (pack package-list)
    (when (not (package-installed-p pack))
      (package-refresh-contents) 
      (package-install pack)))
</code></pre>

<p>Functions package-installed-p, pacakge-refresh-contents and pacakge-install are is offered by package.el. At first, call package-installed-p to check if one package is missed, if so, call package-refresh-contents to get the latest packages info and make them ready for downloading, finally, call package-install to installed missing package. All packages in package-list variable will be saved into ~/.emacs.d directory and loaded automatically.</p></li>
<li><p>Note</p>

<p>Some packages in these repository is too old and cannot work properly. For instance, package &lsquo;slime&rsquo; is not working for now. You have to download slime manually and manage them through the instuction of slime docs.</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/02/lisp-data-structure/">作为数据结构的列表（List），数组（Array）简单数组（Simple Array），向量（Vector）与简单向量（Simple Vector）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-12-02T00:00:00+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>作为数据结构的列表（List），数组（Array）简单数组（Simple Array），向量（Vector）与简单向量（Simple Vector）</p>

<p>在用Lisp实现算法的时候，发现如果只是为了描述一种算法是如何运作的，无论采取什么样的实际数据结构都没有关系。比如描述各种排序算法，用到的数据结构是数组，各种数组的操作主要就是从下标获取数组中元素的值，那么用Lisp来实现，为了表述清楚，可以选择列表，数组，向量，简单向量都行。唯一不同的是，这些实现在实际运行的时候，因为选择了不同的数据结构，在效率上存在很大差异。比如选择数组比选择列表要效率高很多。那么，为了搞清楚围绕他们的一些操作符的效率如何，有必要了解一下Lisp中这些数据结构具体如何实现。对于这些数据结构的定义（或说明）如下：
*   列表（List）：一个列表中的各个元素通过元素之间的指针来索引。比如一个4元素的列表(a b c d)，它的表示如下
    <img src="/images/list.png" alt="列表" />
*   数组（Array）: Lisp支持多维数组，一个完全的使用MAKE-ARRAY来声明数组的细节可以参考Common Lisp HyperSpec.这里先举两个例子： <br/>
    创建一个3维数组，维度分别维2，3，4并且带有初始值：</p>

<pre><code>    (make-array '(2 3 4) :initial-contents '( ((1 2 3 4) (2 3 4 5) (3 4 5 6))
                                              ((0 0 0 0) (1 1 1 1) (2 2 2 2))))


创建一个可变长度的一维数组，初始长度为3：

    ;fill-pointer is an integer associated with the vector, it represents the index and above which no elements are active
    (make-array 3 :adjustable t :fill-pointer 0) 
</code></pre>

<ul>
<li>简单数组（Simple Array）：不与其他数组共享结构，同时没有fill pointers,也不可调整大小。</li>
<li>向量（Vector）：向量极为一维数组，可以用MAKE-ARRAY或者VECTOR函数来创建</li>
<li>简单向量（Simple Vector）：与简单数组的定义相同，简单向量不可调整大小，没有fill pointers，也不与其他向量共享结构。</li>
</ul>


<p>Lisp中的序列指的是列表和向量，针对列表和向量的操作符有：</p>

<ul>
<li>ELT： 比如 <code>(elt seq 2)</code></li>
<li>NTH: 比如 (nth  1 lst)</li>
<li>AREF(对数组操作)：比如<code>(aref two-demision-arrary 2 3)</code>或<code>(aref arr 2)</code>.简单数组和简单向量因为本身也是数组和向量，这个针对数组的操作符对其也适用.同时，对于简单向量，还额外有一个操作符来获取某个位置上的元素：</li>
<li>SVREF:和AREF类似，不同的是，第一个参数必须是一个简单向量.</li>
</ul>


<p>至于不同结构排序时候的效率，列表肯定是最慢，因为每个元素的索引本事就是需要迭代获取的。至于向量和简单向量，则并没有多大区别。</p>

<p>以下是适用合并排序的一个结果，随机产生数组，包含1，800，000个数字</p>

<pre><code>IS simple vector: NIL
Evaluation took:
  3.449 seconds of real time
  3.448972 seconds of total run time (3.355315 user, 0.093657 system)
  [ Run times consist of 0.254 seconds GC time, and 3.195 seconds non-GC time. ]
  100.00% CPU
  8,258,992,983 processor cycles
  1,469,701,840 bytes consed
</code></pre>

<p>&mdash;&mdash;&ndash;以上是向量，以下适用简单向量，排序数组个数1,800,000&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>IS simple vector: T
Evaluation took:
  3.430 seconds of real time
  3.430265 seconds of total run time (3.333013 user, 0.097252 system)
  [ Run times consist of 0.327 seconds GC time, and 3.104 seconds non-GC time. ]
  100.00% CPU
  8,214,305,702 processor cycles
  1,485,606,720 bytes consed
</code></pre>

<p>随机产生数组，包含900，000个数字</p>

<pre><code>IS simple vector: NIL
Evaluation took:
  1.649 seconds of real time
  1.648613 seconds of total run time (1.605715 user, 0.042898 system)
  [ Run times consist of 0.096 seconds GC time, and 1.553 seconds non-GC time. ]
  100.00% CPU
  3,947,813,569 processor cycles
  721,261,328 bytes consed`
</code></pre>

<p>&mdash;&mdash;&ndash;以上是向量，以下适用简单向量，排序数组个数900,000&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>IS simple vector: T
Evaluation took:
  1.671 seconds of real time
  1.670449 seconds of total run time (1.588011 user, 0.082438 system)
  [ Run times consist of 0.066 seconds GC time, and 1.605 seconds non-GC time. ]
  99.94% CPU
  4,000,369,754 processor cycles
  734,046,224 bytes consed`
</code></pre>

<p>随机产生数组，包含500，000个数字</p>

<pre><code>IS simple vector: NIL
Evaluation took:
  0.932 seconds of real time
  0.932690 seconds of total run time (0.898945 user, 0.033745 system)
  [ Run times consist of 0.064 seconds GC time, and 0.869 seconds non-GC time. ]
  100.11% CPU
  2,233,946,007 processor cycles
  396,433,808 bytes consed
</code></pre>

<p>&mdash;&mdash;&ndash;以上是向量，以下适用简单向量，排序数组个数500,000&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>IS simple vector: T
Evaluation took:
  0.850 seconds of real time
  0.850777 seconds of total run time (0.827034 user, 0.023743 system)
  [ Run times consist of 0.047 seconds GC time, and 0.804 seconds non-GC time. ]
  100.12% CPU
  2,037,277,796 processor cycles
  396,432,288 bytes consed
</code></pre>

<p>数据也证实简单数组／向量和数组／向量之间并没有太多效率上的差异，那么为什么要有简单数组／向量呢？ 看来，这篇文章还得继续写下去。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/29/lisp-list-nd-vector/">Lisp List和vector的效率</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-29T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>LISP 在做大序列运算中list 和vector的效率</p>

<p>输入分别是包含3万个元素的列表和向量（一位数组），采用合并排序（Merge Sort），下面是所用时间</p>

<pre><code>Test merge sort by using list
Evaluation took:
  14.406 seconds of real time
  14.401719 seconds of total run time (14.394148 user, 0.007571 system)
  99.97% CPU
  34,497,526,560 processor cycles
  25,904,128 bytes consed

Test merge sort by using vector
Evaluation took:
  0.041 seconds of real time
  0.040773 seconds of total run time (0.040756 user, 0.000017 system)
  100.00% CPU
  97,625,097 processor cycles
  22,743,328 bytes consed
</code></pre>

<p>明显采用向量更加有效率，其原因在于在列表中，如果想查找第m个元素，使用函数 NTH需要在列表上从头做迭代，一直找到第m个元素。而数组取下标通过偏移一次就可以找到。</p>

<p>但是同时也比较了下采用向量的合并排序与系统提供的SORT函数的效率，发现奇特现象，系统提供排序函数效率极高，随着序列的增大，所耗费的时间增长不显著。同时使用列表也似乎不影响其效率。以下是</p>

<p>3万个元素的列表排序。</p>

<pre><code>Test merge sort by sys sort
Evaluation took:
  0.007 seconds of real time
  0.007739 seconds of total run time (0.007738 user, 0.000001 system)
  114.29% CPU
  18,523,509 processor cycles
  0 bytes consed
</code></pre>

<p>6万个元素列表排序：</p>

<pre><code>Test merge sort by sys sort
Evaluation took:
  0.015 seconds of real time
  0.015586 seconds of total run time (0.015582 user, 0.000004 system)
  106.67% CPU
  37,315,730 processor cycles
  0 bytes consed
</code></pre>

<p>12万个元素列表排序：</p>

<pre><code>Test merge sort by sys sort
Evaluation took:
  0.042 seconds of real time
  0.042162 seconds of total run time (0.042148 user, 0.000014 system)
  100.00% CPU
  100,950,376 processor cycles
  0 bytes consed
</code></pre>

<p>24万个元素列表排序：</p>

<pre><code>Test merge sort by sys sort
Evaluation took:
  0.095 seconds of real time
  0.095124 seconds of total run time (0.095093 user, 0.000031 system)
  100.00% CPU
  227,771,817 processor cycles
  0 bytes consed
</code></pre>

<p>系统自带的SORT方法效率很高，24万个元素的排序不到0.1秒就能够完成</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/28/max-sub-seq/">最大子序列问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-28T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>问题：给定一个实数序列，寻找一个子序列，其相加之和为最大。</h1>

<h1>方案：Divide and Conquer</h1>

<p>这里我有两个实现版本，从不同的思路来做Divide， 同时实现上一个采用递归，一个采用循环</p>

<ul>
<li><p> 方法一：如果将序列一分为二，那么中点要么位于这个子序列的右边，要么位于子序列左边，要么刚好在这个子序列上。因此有思路，找到中点左边最大子序列，找到中点右边最大子序列，找到跨越中点的最大子序列，选择其和最大地子序列，即为真正最大的子序列。其中，左右两个序列的子序列的查找是递归的</p></li>
<li><p> 方法二：这个最大的子序列要么从位置0开始，要么从1开始，。。。或者从N-1开始。 因此无非是比较以不同下标开始的子序列中的最大序列。</p></li>
</ul>


<p>代码一：</p>

<pre><code>(defun find-max-crossing-subarray (lst low mid high)
  (let* ((key (nth mid lst)) 
         (count key) 
         (sum-left key) 
         (sum-right key) 
         (left mid)
         (right mid))

    (if (/= low mid)
        (loop for i from (- mid 1) downto low do
              (incf count (nth i lst))
              (when (&gt; count sum-left)
                (setf left i)
                (incf sum-left (nth i lst)))))


    (setf count key)
    (if (/= mid high) 
        (loop for j from (+ mid 1) to high do
              (incf count (nth j lst))
              (when (&gt; count sum-right)
                (setf right j)
                (incf sum-right (nth j lst)))))

                                        ;duplicated count of A[mid]
    (list left right (- (+ sum-left sum-right) key))))


(defun find-maximum-subarray (lst &amp;optional low high)
  (if (eq low  nil) (setf low 0))
  (if (eq high nil) (setf high (- (length lst) 1)))

  (if (= low high) (return-from find-maximum-subarray (list low low (nth low lst))))


  (let* ((mid (floor (+ low high) 2))
         (seq nil)
         (left-seq  (find-maximum-subarray lst low mid))
         (right-seq (find-maximum-subarray lst (1+ mid) high))
         (mid-seq   (find-max-crossing-subarray lst low mid high))
         (v-l (third left-seq))
         (v-m (third mid-seq))
         (v-r (third right-seq)))

    (if (&gt; v-l v-r)
        (if (&gt; v-l v-m)
            (setf seq left-seq)
          (setf seq mid-seq))
      (if (&gt; v-r v-m)
          (setf seq right-seq)
        (setf seq mid-seq)))
    seq))
</code></pre>

<p>代码二：</p>

<pre><code>(defun find-maximum-subarray-2 (lst)

  (let (sum old-sum count seq index low high)
    (loop for i from 0 below (length lst) do
          (setf count 0)
          (loop for j from i below (length lst) do
                (incf count (nth j lst))
                (when (or (not sum) (&gt; count sum))
                  (setf index j)
                  (setf sum count)))


          (when (or (not old-sum) (&gt; sum old-sum))
            (setf low i)
            (setf high index)
            (setf old-sum sum)))
    (list low high old-sum)))
</code></pre>

<p>代码二的实现显著地比代码一地实现短小。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/13/symbol-variable/">Symbol, Variable, Name, Value, What Exactly Are They in Lisp?</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-13T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Symbol, Variable, Name, Value, what exactly are they in Lisp?</p>

<p>Let’s start with some simple expressions we saw many times.</p>

<pre><code>x                     ;the symbol X
()                    ;the empty list
(1 2 3)               ;a list of three numbers
("foo" "bar")         ;a list of two strings
(x y z)               ;a list of three symbols
(x 1 "foo")           ;a list of a symbol, a number, and a string 
(+ (* 2 3) 4)         ;a list of a symbol, a list, and a number
</code></pre>

<p>At first, when we talk about a name, that is always a string, like “foo”, “bar”. They are enclosed with &ldquo; in both sides.</p>

<p>Value in Lisp is a object.</p>

<p>Now we are back to &ldquo;Symbol&rdquo;. Symbol is a data type in Lisp. It is typical a word or a phrase, like APPLE, ABS. Actually, it can be composed by any sequence of letters, digits, and permissible characters.</p>

<p>Every symbol has a name, its name is the just the literal presentation of itself. For example, symbol x has the name “X”.</p>

<p>Symbol may or may not has an value. If a symbol has a value, we call the symbol &ldquo;variable&rdquo;.  That means symbol has a reference to the value (object). For example</p>

<pre><code> (defparameter x  1)
 (symbol-value 'x)  ==&gt; 1
</code></pre>

<p>This creates a symbol X, and binds the value 1 (object 1) to the symbol with name &ldquo;X&rdquo;. X now is a variable. A symbol can also have no value. For example, we just type &lsquo;y in SBCL interpreter, that will create a symbol Y without value assigned.</p>

<pre><code> 'y                 ==&gt; Y
 (symbol-value 'y)
 debugger invoked on a UNBOUND-VARIABLE: The variable Y is unbound.

 Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

 restarts (invokable by number or by possibly-abbreviated name):
   0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-VALUE Y)
0] 0
</code></pre>

<p>In additional of the variable, function definition actually assigns a function object to a symbol</p>

<pre><code> (defun func () (print “hi”))
</code></pre>

<p>This binds symbol FUNC with a function object. So, a symbol can either be a identifier for object (we call it a variable, use <em>symbol-value</em> get the value) or a identifier to function (we call it function, use <em>symbol-function</em> to get the function object)</p>

<p>Let’s take a look the lisp syntax again to review these definition.
<code>(setf x 1)</code> defines a varaible, that creates a symbol and an object then bind them together. The variable name is the symbol name.<br/>
<code>(defun fun() (print 1))</code> defines a function, that creates a symbol and a function object and bind them together. The function name is the symbol name<br/>
And, furthermore, if we do
<code>(setf  myvar ‘hello)</code>, Lisp will create two symbols, MYVAR and HELLO, set value of MYVAR to literal HELLO (set to a symbol object, not “HELLO” string). But Lisp does not assign a value to symbol HELLO, symbol HELLO just has a name attribute.</p>

<p>A full list of symbol attributes are:</p>

<ul>
<li>Name    - a string represents symbol name</li>
<li>Package - indicates which package the symbol belongs to</li>
<li>Property list - …</li>
<li>Value - Used to bind a object.</li>
<li>Function - Used to bind a function object</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/12/asdf/">Use ASDF to Manage Lisp Packages</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-12T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>It seems that Lisp built-in lacking a mechanism to allow user to manager their own programming library just like C/Python/Java . The built-in functions/macros such as &ldquo;defpackage&rdquo;, &ldquo;in-package&rdquo;, &ldquo;load&rdquo;, &ldquo;require&rdquo; is merely for simple organisation of python files. But for a large library that has nested directories and different sub-package. It will soon become complicated to load them and to resolve the dependencies.</p>

<p>So, we have ASDF. ASDF is &ldquo;A system definition facility&rdquo;. Just like autotool in C, it can manage the correlations between files in your library, compiling them, loading them for your use.</p>

<p>I am using SBCL, it has ASDF library included by default. And, currently ASDF 3 is published. As i am a new comer, following the official instruction of ASDF website. Just familiar with ASDF 3 is enough, no burden of legacy interfaces.  Here is some essentials to ASDF and i will illustrate how to use ASDF to build my hello world library.
First, define a hello.asd (always use the .asd suffix, just like suffix &ldquo;.in&rdquo; for autoconf). This file describes your system. Find more details about usage in ASDF manual. In this example, we just define 3 additional files: packages.lisp, macros.lisp, and hello.lisp and set their dependencies.</p>

<pre><code>(asdf:defsystem :hello
  :name "Hello System"
  :description "hello: a sample file system."
  :version "0.2.1"
  :author "Wu Li &lt;who@unknown.com&gt;"
  :licence "Public Domain"
  :components ((:file "packages")
               (:file "macros" :depends-on ("packages"))
               (:file "hello"  :depends-on ("macros"))))
</code></pre>

<p>Define your package in package.lisp. Here we define a new package :hello and set a nick name HI.</p>

<pre><code>(defpackage :hello
  (:nicknames hi)
  (:use :common-lisp)
  (:export main))
</code></pre>

<p>Leave macros.lisp empty for simplicity.
Define hello.lisp. We just define one function here.</p>

<pre><code>(in-package :hello)
(defun main () (format t "Hello world~%"))
</code></pre>

<p>So far, we have programs and we defined the package by using ASDF, then we can use ASDF to load this package for use.</p>

<p>Load package.</p>

<pre><code>(require :ASDF)                     ;load ASDF package if necessary
(push #P"/path/to/the/package/" asdf:*central-registry*) ;tell ASDF where the lib can be found
(asdf:load-system :hello)   ;the symbol should be identical with the one defined in hello.asd
</code></pre>

<p>Run function owned by hello package</p>

<pre><code>(hi:main) -&gt; Hello world            ;hi is a nickname to hello package
</code></pre>

<p>This is a standard use of ASDF to build package.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/10/lisp-string/">Lisp字符串处理的一些方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-10T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>lisp字符串处理的一些方法</p>

<p>Lisp的字符串处理函数是相对贫乏。一些常用的操作，如split, replace, join没有提供。相对于其他的高级语言，比如Python，不能不说有些差距。</p>

<p>这里对照Python提供的字符串相关方法和函数，来比较下Lisp是否有相应的实现。第一列是Python的字符串方法或者函数，第二列是Lisp对应的函数，如果为空，则代表没有相应的处理函数。</p>

<p>首先，比较常用的字符串操作，与Python相比较，如下图:</p>

<table border=1>
    <tr>
        <th>Python</th>
        <th>Lisp</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>s.capitalize</td>
        <td>STRING-CAPITALIZE</td>
        <td>(string-capitalize &#8220;this IS A BOOK”) ->  &#8220;This Is A Book” &#8220;this IS A BOOK&#8221;.capitalize() ->  &#8216;This is a book’ Lisp中的CAPITALIZE函数与Python字符串的Capitalize的效果是不一样的，它实际上的效果与Python字符串的title方法一样
        </td>
    </tr>
    <tr>
        <td>s.center</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>s.count </td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>s.encode    </td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>s.decode            </td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>s.endswith          </td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>s.expandtabs            </td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>s.find          </td>
        <td>POSITION FIND SEARCH </td>
        <td>Lisp有三个函数来查找特定的子串，其中position和find查找单个字符，search查找子字符串。position和find的不同在于，find返回的是匹配的字符串，而不是下标索引值
        </td>
    </tr>
    <tr><td>s.format</td><td>FORMAT</td><td></td></tr>
    <tr><td>s.index </td><td>POSITION FIND SEARCH       </td><td></td></tr>
    <tr><td>s.isalnum</td><td></td><td></td></tr>
    <tr><td>s.isalpha</td><td></td><td></td></tr>
    <tr><td>s.isdigit</td><td></td><td></td></tr>
    <tr><td>s.islower</td><td></td><td></td></tr>
    <tr><td>s.isspace</td><td></td><td></td></tr>
    <tr><td>s.istitle</td><td></td><td></td></tr>
    <tr><td>s.isupper</td><td></td><td></td></tr>
    <tr><td>s.join</td><td></td><td></td></tr>
    <tr><td>s.ljust </td><td></td><td></td></tr>
    <tr><td>s.lower     </td><td>   STRING-DOWNCASE</td><td></td></tr>
    <tr><td>s.lstrip        </td><td>STRING-LEFT-TRIM</td><td></td></tr>
    <tr><td>s.partition</td></td><td></td></tr>
    <tr><td>s.replace</td><td></td><td>LISP has REPLACE function, but they have different definition</td></tr>
    <tr><td>s.rfind</td><td></td><td></td></tr>
    <tr><td>s.rjust </td><td></td><td></td></tr>
    <tr><td>s.rpartition</td><td></td><td></td></tr>
    <tr><td>s.rsplit</td><td></td><td></td></tr>
    <tr><td>s.rstrip        </td><td>STRING-RIGHT-TRIM</td><td></td></tr>
    <tr><td>s.split</td><td></td><td></td></tr>
    <tr><td>s.splitlines</td><td></td><td></td></tr>
    <tr><td>s.startswith</td><td></td><td></td></tr>
    <tr><td>s.strip </td><td>STRING-TRIM</td><td></td></tr>
    <tr><td>s.swapcase</td><td></td><td></td></tr>
    <tr><td>s.title</td>STRING-CAPITALIZE</td><td></td></tr>
    <tr><td>s.translate</td><td></td><td></td></tr>
    <tr><td>s.upper     </td><td>   STRING-UPCASE </td><td></td></tr>
    <tr><td>s.zfill </td><td></td><td></td></tr>
    <tr><td>sorted(s)</td><td>SORT</td><td></td></tr>
    <tr><td>reversed(s) </td><td>REVERSE</td><td></td></tr>
</table>


<p>再比较字符串与数字转换的一些操作:</p>

<table border=1>
    <tr><th>Python</th><th>Lisp</th><th>说明</th></tr>
    <tr><td>int</td><td>PARSE-INTEGER</td><td>字符串转换成数字</td></tr>
    <tr><td>str</td><td>WRITE-TO-STRING</td><td>数字穿换成字符串</td></tr>
    <tr><td>ord</td><td>CHAR-CODE</td><td>字符的数字值</td></tr>
    <tr><td>chr</td><td>CODE-CHAR</td><td>数字值转换成字符</td></tr>
</table>


<p>第二列所列举的Lisp的字符串处理函数中，很多都是缺失的。而这些缺失的函数里面，以下的几个关键操作比较让人难以容忍。它们是replacing, splitting，join操作</p>

<p>split根据给定的分割字符串来分割目标字符串，我们可以定义为
<code>(defun split (delimiters str) body*)</code><br/>
因为lisp已经有了一个叫做replace的函数，用以替换给定位置上的字符串，同时有另外一个函数substitute，用来替换字符串中的字符。这两个函数都不能够完成寻找并替换匹配的子字符串。因此定义另外一个函数在完成子字符串的替换。<br/>
<code>(defun replace-all (from to target) body*)</code><br/>
还有一个是join，接受一个分割的字符串，把给定列表中的字符串用此分割字符串拼接起来<br/>
<code>(defun join (str lst) body*)</code></p>

<p>可以自己实现这些函数，也可以直接使用其他的库提供的接口。这样的包包括cl-ppcre，提供与Perl兼容的正则表达式处理接口。可以使用它的splitting和replacing相关的函数，这些函数不单可以作用在简单的字符串上面，还可以匹配正则表达式，功能很强大.</p>

<p>cl-ppcre提供的相关函数如下：</p>

<pre><code>split regex target-string &amp;key start end limit with-registers-p omit-unmatched-p sharedp =&gt; list
(split “ab” “eeeabc”) -&gt; (“eee” “c”)

regex-replace-all regex target-string replacement &amp;key start end preserve-case simple-calls element-type =&gt; string, match
(regex-replace-all "ab" "eeeabc" "df”)
</code></pre>

<p>这两个例子是简单的匹配，没有用到复杂的正则表达式。详细可见cl-ppcre文档:<a href="http://weitz.de/cl-ppcre">http://weitz.de/cl-ppcre</a></p>

<p>cl-utilties也提供另外一个版本的split，相对功能简单点。只能够从sequence里面根据指定的delimiter来分割序列，这个delimiter不是一个集合，只是单独的一个object。</p>

<p>至于自己实现这3个函数，其实也不难，代码如下：</p>

<pre><code>(defun split (delimiters s)
  (flet ((delimiterp (c) 
               (position c delimiters)))
    (let ((slices nil) (substr nil))
      (loop for c across s do
         (if (not (delimiterp c))
          (setf substr (concatenate 'string substr (string c)))
           (when substr
          (setf slices (append slices (list substr)))
          (setf substr nil))))
      ;append last substring
      (if substr  (setf slices (append slices (list substr))))
      slices)))


(defun join (str lst)
    (reduce  #'(lambda (sum ele) (concatenate 'string (string sum) str  (string ele))) lst))

(defun replace-all (from to target)
  (let ((sum nil) (begin 0) (end t))
    (loop while end do
       (setf end (search from target :start2 begin))
       (print end)
       (when end
         (setf sum (concatenate 'string sum (subseq target begin end) to))
         (setf begin (+ end (length from)))))
    sum)) 
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/15/pythonexp2/">Python 语言使用回顾</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/09/pythonexp/">Python 语言使用回顾</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/24/resume/">Resume</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/04/closures/">闭包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/30/legb/">LEGB规则与 Python 变量的存取</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Wu Li -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'httpwulimobi';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
